{"version":1,"tree":{"n":"html","a":[["lang","zh",1],["lang","zh"]],"c":[{"n":"head","x":"\n\n","l":"\n","c":[{"n":"title","x":"Git 与其他系统","l":"\n"},{"n":"link","l":"\n","a":[["rel","stylesheet"],["type","text/css"],["href","styles/epub3.css"]]},{"n":"link","l":"\n","a":[["rel","stylesheet"],["type","text/css"],["href","styles/epub3-css3-only.css"],["media","(min-device-width: 0px)"]]},{"n":"script","x":"\ndocument.addEventListener('DOMContentLoaded', function(event, reader) {\n  if (!(reader = navigator.epubReadingSystem)) {\n    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };\n    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;\n  }\n  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));\n});\n","l":"\n","a":[["type","text/javascript"]]}]},{"n":"body","x":"\n","l":"\n","c":[{"n":"section","x":"\n","l":"\n","a":[["class","chapter"],["title","Git 与其他系统"],["type","chapter",2],["id","ch09-git-and-other-systems"]],"c":[{"n":"header","x":"\n","l":"\n","c":[{"n":"div","x":"\n","l":"\n","a":[["class","chapter-header"]],"c":[{"n":"h1","l":"\n","a":[["class","chapter-title"]],"c":[{"n":"small","a":[["class","subtitle"]],"c":[{"n":"b","x":"Git","l":" "},{"n":"b","x":"与其他系统"}]}]}]}]},{"n":"p","x":"现实并不总是尽如人意。\n通常，你不能立刻就把接触到的每一个项目都切换到 Git。\n有时候你被困在使用其他 VCS 的项目中，却希望使用 Git。\n在本章的第一部分我们将会了解到，怎样在你的那些托管在不同系统的项目上使用 Git 客户端。","l":"\n"},{"n":"p","x":"在某些时候，你可能想要将已有项目转换到 Git。\n本章的第二部分涵盖了从几个特定系统将你的项目迁移至 Git 的方法，即使没有预先构建好的导入工具，我们也有办法手动导入。","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","作为客户端的 Git"]],"c":[{"n":"h2","x":"作为客户端的 Git","l":"\n","a":[["id","_作为客户端的_git"]]},{"n":"p","x":"\nGit 为开发者提供了如此优秀的体验，许多人已经找到了在他们的工作站上使用 Git 的方法，即使他们团队其余的人使用的是完全不同的 VCS。\n有许多这种可用的适配器，它们被叫做“桥接”。\n下面我们将要介绍几个很可能会在实际中用到的桥接。","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Git 与 Subversion"]],"c":[{"n":"h3","x":"Git 与 Subversion","l":"\n","a":[["id","_git_svn"]]},{"n":"p","x":"\n很大一部分开源项目与相当多的企业项目使用 Subversion 来管理它们的源代码。\n而且在大多数时间里，它已经是开源项目 VCS 选择的 ","l":"\n","c":[{"n":"em","x":"事实标准","l":"。\n它在很多方面都与曾经是源代码管理世界的大人物的 CVS 相似。"}]},{"n":"p","x":"\nGit 中最棒的特性就是有一个与 Subversion 的双向桥接，它被称作 ","l":"\n","c":[{"n":"code","x":"git svn","l":"。\n这个工具允许你使用 Git 作为连接到 Subversion 有效的客户端，这样你可以使用 Git 所有本地的功能然后如同正在本地使用 Subversion 一样推送到 Subversion 服务器。\n这意味着你可以在本地做新建分支与合并分支、使用暂存区、使用变基与拣选等等的事情，同时协作者还在继续使用他们黑暗又古老的方式。\n当你试图游说公司将基础设施修改为完全支持 Git 的过程中，一个好方法是将 Git 偷偷带入到公司环境，并帮助周围的开发者提升效率。\nSubversion 桥接就是进入 DVCS 世界的诱饵。","a":[["class","literal"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","git svn"]],"c":[{"n":"h4","l":"\n","a":[["id","_code_class_literal_git_svn_code"]],"c":[{"n":"code","x":"git svn","a":[["class","literal"]]}]},{"n":"p","x":"在 Git 中所有 Subversion 桥接命令的基础命令是 ","l":"\n","c":[{"n":"code","x":"git svn","l":"。\n它可以跟很多命令，所以我们会通过几个简单的工作流程来为你演示最常用的命令。","a":[["class","literal"]]}]},{"n":"p","x":"需要特别注意的是当你使用 ","l":"\n","c":[{"n":"code","x":"git svn","l":" 时，就是在与 Subversion 打交道，一个与 Git 完全不同的系统。\n尽管 ","a":[["class","literal"]]},{"n":"strong","x":"可以","l":" 在本地新建分支与合并分支，但是你最好还是通过变基你的工作来保证你的历史尽可能是直线，并且避免做类似同时与 Git 远程服务器交互的事情。"}]},{"n":"p","x":"不要重写你的历史然后尝试再次推送，同时也不要推送到一个平行的 Git 仓库来与其他使用 Git 的开发者协作。\nSubversion 只能有一个线性的历史，弄乱它很容易。\n如果你在一个团队中工作，其中有一些人使用 SVN 而另一些人使用 Git，你需要确保每个人都使用 SVN 服务器来协作——这样做会省去很多麻烦。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","设置"]],"c":[{"n":"h4","x":"设置","l":"\n","a":[["id","_设置"]]},{"n":"p","x":"为了演示这个功能，需要一个有写入权限的典型 SVN 仓库。\n如果想要拷贝这些例子，你必须获取一份可写入的 SVN 测试仓库的副本。\n为了轻松地拷贝，可以使用 Subversion 自带的一个名为 ","l":"\n","c":[{"n":"code","x":"svnsync","l":" 的工具。\n为了这些测试，我们在 Google Code 上创建了一个 ","a":[["class","literal"]]},{"n":"code","x":"protobuf","l":" 项目部分拷贝的新\nSubversion 仓库。","a":[["class","literal"]]},{"n":"code","x":"protobuf","l":" 是一个将结构性数据编码用于网络传输的工具。","a":[["class","literal"]]}]},{"n":"p","x":"接下来，你需要先创建一个新的本地 Subversion 仓库：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"mkdir /tmp/test-svn\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"svnadmin create /tmp/test-svn","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"然后，允许所有用户改变版本属性——最容易的方式是添加一个返回值为 0 的 ","l":"\n","c":[{"n":"code","x":"pre-revprop-change","l":" 脚本。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"cat /tmp/test-svn/hooks/pre-revprop-change\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#","l":"!/bin/sh\nexit 0;\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"chmod +x /tmp/test-svn/hooks/pre-revprop-change","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在可以调用加入目标与来源仓库参数的 ","l":"\n","c":[{"n":"code","x":"svnsync init","l":" 命令同步这个项目到本地的机器。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"svnsync init file:///tmp/test-svn ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\\","l":"\n  http://your-svn-server.example.org/svn/","a":[["style","font-weight: bold; font-style: italic"]]}]}]}]},{"n":"p","x":"这样就设置好了同步所使用的属性。\n可以通过运行下面的命令来克隆代码：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"svnsync sync file:///tmp/test-svn\nCommitted revision 1.\nCopied properties for revision 1.\nTransmitting file data .............................[...]\nCommitted revision 2.\nCopied properties for revision 2.\n[…]","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"虽然这个操作可能只会花费几分钟，但如果你尝试拷贝原始的仓库到另一个非本地的远程仓库时，即使只有不到 100 个的提交，这个过程也可能会花费将近一个小时。\nSubversion 必须一次复制一个版本然后推送回另一个仓库——这低效得可笑，但却是做这件事唯一简单的方式。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","开始"]],"c":[{"n":"h4","x":"开始","l":"\n","a":[["id","_开始"]]},{"n":"p","x":"既然已经有了一个有写入权限的 Subversion 仓库，那么你可以开始一个典型的工作流程。\n可以从 ","l":"\n","c":[{"n":"code","x":"git svn clone","l":" 命令开始，它会将整个 Subversion 仓库导入到一个本地 Git 仓库。\n需要牢记的一点是如果是从一个真正托管的 Subversion 仓库中导入，需要将 ","a":[["class","literal"]]},{"n":"code","x":"file:///tmp/test-svn","l":" 替换为你的 Subversion 仓库的 URL：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn clone file:///tmp/test-svn -T trunk -b branches -t tags\nInitialized empty Git repository in /private/tmp/progit/test-svn/.git/\nr1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)\n    A\tm4/acx_pthread.m4\n    A\tm4/stl_hash.m4\n    A\tjava/src/test/java/com/google/protobuf/UnknownFieldSetTest.java\n    A\tjava/src/test/java/com/google/protobuf/WireFormatTest.java\n…\nr75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)\nFound possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/my-calc-branch, 75\nFound branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae\nFollowing parent with do_switch\nSuccessfully followed parent\nr76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)\nChecked out HEAD:\n  file:///tmp/test-svn/trunk r75","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这相当于运行了两个命令—— ","l":"\n","c":[{"n":"code","x":"git svn init","l":" 以及紧接着的 ","a":[["class","literal"]]},{"n":"code","x":"git svn fetch","l":" ——你提供的 URL。\n这会花费一些时间。例如，如果测试项目只有 75 个左右的提交并且代码库并不是很大，\n但是 Git 必须一次一个地检出一个版本同时单独地提交它。\n对于有成百上千个提交的项目，这真的可能会花费几小时甚至几天来完成。","a":[["class","literal"]]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"-T trunk -b branches -t tags","l":" 部分告诉 Git Subversion 仓库遵循基本的分支与标签惯例。\n如果你命名了不同的主干、分支或标签，可以修改这些参数。\n因为这是如此地常见，所以能用 ","a":[["class","literal"]]},{"n":"code","x":"-s","l":" 来替代整个这部分，这表示标准布局并且指代所有那些选项。\n下面的命令是相同的：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn clone file:///tmp/test-svn -s","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"至此，应该得到了一个已经导入了分支与标签的有效的 Git 仓库：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git branch -a\n* master\n  remotes/origin/my-calc-branch\n  remotes/origin/tags/2.0.2\n  remotes/origin/tags/release-2.0.1\n  remotes/origin/tags/release-2.0.2\n  remotes/origin/tags/release-2.0.2rc1\n  remotes/origin/trunk","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意这个工具是如何将 Subversion 标签作为远程引用来管理的。\n\n让我们近距离看一下 Git 的底层命令 ","l":"\n","c":[{"n":"code","x":"show-ref","l":"：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git show-ref\n556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master\n0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch\nbfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2\n285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1\ncbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2\na9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1\n556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"Git 在从 Git 服务器克隆时并不这样做；下面是在刚刚克隆完成的有标签的仓库的样子：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git show-ref\nc3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master\n32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1\n75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2\n23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0\n7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0\n6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"Git 直接将标签抓取至 ","l":"\n","c":[{"n":"code","x":"refs/tags","l":"，而不是将它们看作分支。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","提交回 Subversion"]],"c":[{"n":"h4","x":"提交回 Subversion","l":"\n","a":[["id","_提交回_subversion"]]},{"n":"p","x":"现在你有了一个工作目录，你可以在项目上做一些改动，然后高效地使用 Git 作为 SVN 客户端将你的提交推送到上游。\n一旦编辑了一个文件并提交它，你就有了一个存在于本地 Git 仓库的提交，这提交在 Subversion 服务器上并不存在：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git commit -am ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'Adding git-svn instructions to the README'","l":"\n[master 4af61fd] Adding git-svn instructions to the README\n 1 file changed, 5 insertions(+)","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"接下来，你需要将改动推送到上游。\n注意这会怎样改变你使用 Subversion 的方式——你可以离线做几次提交然后一次性将它们推送到 Subversion 服务器。\n要推送到一个 Subversion 服务器，运行 ","l":"\n","c":[{"n":"code","x":"git svn dcommit","l":" 命令：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn dcommit\nCommitting to file:///tmp/test-svn/trunk ...\n    M\tREADME.txt\nCommitted r77\n    M\tREADME.txt\nr77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)\nNo changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk\nResetting to the latest refs/remotes/origin/trunk","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这会拿走你在 Subversion 服务器代码之上所做的所有提交，针对每一个做一个 Subversion 提交，然后重写你本地的 Git 提交来包含一个唯一的标识符。\n这很重要因为这意味着所有你的提交的 SHA-1 校验和都改变了。\n部分由于这个原因，同时使用一个基于 Git 的项目远程版本和一个 Subversion 服务器并不是一个好主意。\n如果你查看最后一次提交，有新的 ","l":"\n","c":[{"n":"code","x":"git-svn-id","l":" 被添加：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log -1\ncommit 95e0222ba6399739834380eb10afcd73e0670bc5\nAuthor: ben <ben@0b684db3-b064-4277-89d1-21af03df0a68>\nDate:   Thu Jul 24 03:08:36 2014 +0000\n\n    Adding git-svn instructions to the README\n\n    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意你原来提交的 SHA-1 校验和原来是以 ","l":"\n","c":[{"n":"code","x":"4af61fd","l":" 开头，而现在是以 ","a":[["class","literal"]]},{"n":"code","x":"95e0222","l":" 开头。\n如果想要既推送到一个 Git 服务器又推送到一个 Subversion 服务器，必须先推送（","a":[["class","literal"]]},{"n":"code","x":"dcommit","l":"）到 Subversion 服务器，因为这个操作会改变你的提交数据。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","拉取新改动"]],"c":[{"n":"h4","x":"拉取新改动","l":"\n","a":[["id","_拉取新改动"]]},{"n":"p","x":"如果你和其他开发者一起工作，当在某一时刻你们其中之一推送时，另一人尝试推送修改会导致冲突。\n那次修改会被拒绝直到你合并他们的工作。\n在 ","l":"\n","c":[{"n":"code","x":"git svn","l":" 中，它看起来是这样的：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn dcommit\nCommitting to file:///tmp/test-svn/trunk ...\n\nERROR from SVN:\nTransaction is out of date: File '/trunk/README.txt' is out of date\nW: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:\n:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M\tREADME.txt\nCurrent branch master is up to date.\nERROR: Not all changes have been committed into SVN, however the committed\nones (if any) seem to be successfully integrated into the working tree.\nPlease see the above messages for details.","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"为了解决这种情况，可以运行 ","l":"\n","c":[{"n":"code","x":"git svn rebase","l":"，它会从服务器拉取任何你本地还没有的改动，并将你所有的工作变基到服务器的内容之上：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn rebase\nCommitting to file:///tmp/test-svn/trunk ...\n\nERROR from SVN:\nTransaction is out of date: File '/trunk/README.txt' is out of date\nW: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:\n:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M\tREADME.txt\nFirst, rewinding head to replay your work on top of it...\nApplying: update foo\nUsing index info to reconstruct a base tree...\nM\tREADME.txt\nFalling back to patching base and 3-way merge...\nAuto-merging README.txt\nERROR: Not all changes have been committed into SVN, however the committed\nones (if any) seem to be successfully integrated into the working tree.\nPlease see the above messages for details.","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在，所有你的工作都已经在 Subversion 服务器的内容之上了，你就可以顺利地 ","l":"\n","c":[{"n":"code","x":"dcommit","l":"：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn dcommit\nCommitting to file:///tmp/test-svn/trunk ...\n    M\tREADME.txt\nCommitted r85\n    M\tREADME.txt\nr85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)\nNo changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk\nResetting to the latest refs/remotes/origin/trunk","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意，和 Git 需要你在推送前合并本地还没有的上游工作不同的是，","l":"\n","c":[{"n":"code","x":"git svn","l":" 只会在修改发生冲突时要求你那样做（更像是 Subversion 工作的行为）。\n如果其他人推送一个文件的修改然后你推送了另一个文件的修改，你的 ","a":[["class","literal"]]},{"n":"code","x":"dcommit","l":" 命令会正常工作：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn dcommit\nCommitting to file:///tmp/test-svn/trunk ...\n    M\tconfigure.ac\nCommitted r87\n    M\tautogen.sh\nr86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)\n    M\tconfigure.ac\nr87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)\nW: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:\n:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M\tautogen.sh\nFirst, rewinding head to replay your work on top of it...","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"记住这一点很重要，因为结果是当你推送后项目的状态并不存在于你的电脑中。\n如果修改并未冲突但却是不兼容的，可能会引起一些难以诊断的问题。\n这与使用 Git 服务器并不同——在 Git 中，可以在发布前完全测试客户端系统的状态，然而在 SVN 中，你甚至不能立即确定在提交前与提交后的状态是相同的。","l":"\n"},{"n":"p","x":"你也应该运行这个命令从 Subversion 服务器上拉取修改，即使你自己并不准备提交。\n可以运行 ","l":"\n","c":[{"n":"code","x":"git svn fetch","l":" 来抓取新数据，但是 ","a":[["class","literal"]]},{"n":"code","x":"git svn rebase","l":" 会抓取并更新你本地的提交。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn rebase\n    M\tautogen.sh\nr88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)\nFirst, rewinding head to replay your work on top of it...\nFast-forwarded master to refs/remotes/origin/trunk.","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"每隔一会儿运行 ","l":"\n","c":[{"n":"code","x":"git svn rebase","l":" 确保你的代码始终是最新的。\n虽然需要保证当运行这个命令时工作目录是干净的。\n如果有本地的修改，在运行 ","a":[["class","literal"]]},{"n":"code","x":"git svn rebase","l":" 之前要么储藏你的工作要么做一次临时的提交，不然，当变基会导致合并冲突时，命令会终止。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git 分支问题"]],"c":[{"n":"h4","x":"Git 分支问题","l":"\n","a":[["id","_git_分支问题"]]},{"n":"p","x":"当适应了 Git 的工作流程，你大概会想要创建主题分支，在上面做一些工作，然后将它们合并入主分支。\n如果你正通过 ","l":"\n","c":[{"n":"code","x":"git svn","l":" 推送到一个 Subversion 服务器，你可能想要把你的工作变基到一个单独的分支上，而不是将分支合并到一起。\n比较喜欢变基的原因是因为 Subversion 有一个线性的历史并且无法像 Git 一样处理合并，所以 ","a":[["class","literal"]]},{"n":"code","x":"git svn","l":" 在将快照转换成 Subversion 提交时，只会保留第一父提交。","a":[["class","literal"]]}]},{"n":"p","x":"假设你的历史像下面这样：创建了一个 ","l":"\n","c":[{"n":"code","x":"experiment","l":" 分支，做了两次提交，然后将它们合并回 ","a":[["class","literal"]]},{"n":"code","x":"master","l":"。\n当 ","a":[["class","literal"]]},{"n":"code","x":"dcommit","l":" 时，你看到输出是这样的：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn dcommit\nCommitting to file:///tmp/test-svn/trunk ...\n    M\tCHANGES.txt\nCommitted r89\n    M\tCHANGES.txt\nr89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)\n    M\tCOPYING.txt\n    M\tINSTALL.txt\nCommitted r90\n    M\tINSTALL.txt\n    M\tCOPYING.txt\nr90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)\nNo changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk\nResetting to the latest refs/remotes/origin/trunk","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"在一个合并过历史提交的分支上 ","l":"\n","c":[{"n":"code","x":"dcommit","l":" 命令工作得很好，除了当你查看你的 Git 项目历史时，它并没有重写所有你在 ","a":[["class","literal"]]},{"n":"code","x":"experiment","l":" 分支上所做的任意提交——相反，所有这些修改显示一个单独合并提交的 SVN 版本中。","a":[["class","literal"]]}]},{"n":"p","x":"当其他人克隆那些工作时，他们只会看到一个被塞入了所有改动的合并提交，就像运行了 ","l":"\n","c":[{"n":"code","x":"git merge --squash","l":"；他们无法看到修改从哪来或何时提交的信息。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Subversion 分支"]],"c":[{"n":"h4","x":"Subversion 分支","l":"\n","a":[["id","_subversion_分支"]]},{"n":"p","x":"在 Subversion 中新建分支与在 Git 中新建分支并不相同；如果你能不用它，那最好就不要用。\n然而，你可以使用 ","l":"\n","c":[{"n":"code","x":"git svn","l":" 在 Subversion 中创建分支并在分支上做提交。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","创建一个新的 SVN 分支"]],"c":[{"n":"h4","x":"创建一个新的 SVN 分支","l":"\n","a":[["id","_创建一个新的_svn_分支"]]},{"n":"p","x":"要在 Subversion 中创建一个新分支，运行 ","l":"\n","c":[{"n":"code","x":"git svn branch <new-branch>","l":"：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn branch opera\nCopying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...\nFound possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/opera, 90\nFound branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0\nFollowing parent with do_switch\nSuccessfully followed parent\nr91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这与 Subversion 中的 ","l":"\n","c":[{"n":"code","x":"svn copy trunk branches/opera","l":" 命令作用相同并且是在 Subversion 服务器中操作。\n需要重点注意的是它并不会检出到那个分支；如果你在这时提交，提交会进入服务器的 ","a":[["class","literal"]]},{"n":"code","x":"trunk","l":" 分支，而不是 ","a":[["class","literal"]]},{"n":"code","x":"opera","l":" 分支。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","切换活动分支"]],"c":[{"n":"h4","x":"切换活动分支","l":"\n","a":[["id","_切换活动分支"]]},{"n":"p","x":"Git 通过查找在历史中 Subversion 分支的头部来指出你的提交将会到哪一个分支——应该只有一个，并且它应该是在当前分支历史中最后一个有 ","l":"\n","c":[{"n":"code","x":"git-svn-id","l":" 的。","a":[["class","literal"]]}]},{"n":"p","x":"如果想要同时在不止一个分支上工作，可以通过在导入的那个分支的 Subversion 提交开始来设置本地分支 ","l":"\n","c":[{"n":"code","x":"dcommit","l":" 到特定的 Subversion 分支。\n如果想要一个可以单独在上面工作的 ","a":[["class","literal"]]},{"n":"code","x":"opera","l":" 分支，可以运行","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git branch opera remotes/origin/opera","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在，如果想要将你的 ","l":"\n","c":[{"n":"code","x":"opera","l":" 分支合并入 ","a":[["class","literal"]]},{"n":"code","x":"trunk","l":"（你的 ","a":[["class","literal"]]},{"n":"code","x":"master","l":" 分支），可以用一个正常的 ","a":[["class","literal"]]},{"n":"code","x":"git merge","l":" 来这样做。\n但是你需要通过 ","a":[["class","literal"]]},{"n":"code","x":"-m","l":" 来提供一个描述性的提交信息，否则合并信息会是没有用的 “Merge branch opera”。","a":[["class","literal"]]}]},{"n":"p","x":"记住尽管使用的是 ","l":"\n","c":[{"n":"code","x":"git merge","l":" 来做这个操作，而且合并可能会比在 Subversion 中更容易一些\n（因为 Git 会为你自动地检测合适的合并基础），但这并不是一个普通的 Git 合并提交。\n你不得不将这个数据推送回一个 Subversion 服务器，Subversion 服务器不支持那些跟踪多个父结点的提交；\n所以，当推送完成后，它看起来会是一个将其他分支的所有提交压缩在一起的单独提交。\n在合并一个分支到另一个分支后，你并不能像 Git 中那样轻松地回到原来的分支继续工作。\n你运行的 ","a":[["class","literal"]]},{"n":"code","x":"dcommit","l":" 命令会将哪个分支被合并进来的信息抹掉，所以后续的合并基础计算会是错的——\n","a":[["class","literal"]]},{"n":"code","x":"dcommit","l":" 会使你的 ","a":[["class","literal"]]},{"n":"code","x":"git merge","l":" 结果看起来像是运行了 ","a":[["class","literal"]]},{"n":"code","x":"git merge --squash","l":"。\n不幸的是，没有一个好的方式来避免这种情形—— Subversion 无法存储这个信息，\n所以当使用它做为服务器时你总是会被它的限制打垮。\n为了避免这些问题，应该在合并到主干后删除本地分支（本例中是 ","a":[["class","literal"]]},{"n":"code","x":"opera","l":"）。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Subversion 命令"]],"c":[{"n":"h4","x":"Subversion 命令","l":"\n","a":[["id","_subversion_命令"]]},{"n":"p","l":"\n","c":[{"n":"code","x":"git svn","l":" 工具集通过提供很多功能与 Subversion 中那些相似的命令来帮助简化转移到 Git 的过程。\n下面是一些提供了 Subversion 中常用功能的命令。","a":[["class","literal"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","SVN 风格历史"]],"c":[{"n":"h5","x":"SVN 风格历史","l":"\n","a":[["id","_svn_风格历史"]]},{"n":"p","x":"如果你习惯于使用 Subversion 并且想要看 SVN 输出风格的提交历史，可以运行 ","l":"\n","c":[{"n":"code","x":"git svn log","l":" 来查看 SVN 格式的提交历史：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn log\n------------------------------------------------------------------------\nr87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines\n\nautogen change\n\n------------------------------------------------------------------------\nr86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines\n\nMerge branch 'experiment'\n\n------------------------------------------------------------------------\nr85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines\n\nupdated the changelog","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"关于 ","l":"\n","c":[{"n":"code","x":"git svn log","l":"，有两件重要的事你应该知道。\n首先，它是离线工作的，并不像真正的 ","a":[["class","literal"]]},{"n":"code","x":"svn log","l":" 命令，会向 Subversion 服务器询问数据。\n其次，它只会显示已经提交到 Subversion 服务器上的提交。\n还未 dcommit 的本地 Git 提交并不会显示；同样也不会显示这段时间中其他人推送到 Subversion 服务器上的提交。\n它更像是最后获取到的 Subversion 服务器上的提交状态。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","SVN 注解"]],"c":[{"n":"h5","x":"SVN 注解","l":"\n","a":[["id","_svn_注解"]]},{"n":"p","x":"类似 ","l":"\n","c":[{"n":"code","x":"git svn log","l":" 命令离线模拟了 ","a":[["class","literal"]]},{"n":"code","x":"svn log","l":" 命令，你可以认为 ","a":[["class","literal"]]},{"n":"code","x":"git svn blame [FILE]","l":" 离线模拟了 ","a":[["class","literal"]]},{"n":"code","x":"svn annotate","l":"。\n输出看起来像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn blame README.txt\n 2   temporal Protocol Buffers - Google's data interchange format\n 2   temporal Copyright 2008 Google Inc.\n 2   temporal http://code.google.com/apis/protocolbuffers/\n 2   temporal\n22   temporal C++ Installation - Unix\n22   temporal =======================\n 2   temporal\n79    schacon Committing in git-svn.\n78    schacon\n 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol\n 2   temporal Buffer compiler (protoc) execute the following:\n 2   temporal","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"重复一次，它并不显示你在 Git 中的本地提交，也不显示同一时间被推送到 Subversion 的其他提交。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","SVN 服务器信息"]],"c":[{"n":"h5","x":"SVN 服务器信息","l":"\n","a":[["id","_svn_服务器信息"]]},{"n":"p","x":"可以通过运行 ","l":"\n","c":[{"n":"code","x":"git svn info","l":" 得到与 ","a":[["class","literal"]]},{"n":"code","x":"svn info","l":" 相同种类的信息。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn info\nPath: .\nURL: https://schacon-test.googlecode.com/svn/trunk\nRepository Root: https://schacon-test.googlecode.com/svn\nRepository UUID: 4c93b258-373f-11de-be05-5f7a86268029\nRevision: 87\nNode Kind: directory\nSchedule: normal\nLast Changed Author: schacon\nLast Changed Rev: 87\nLast Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这就像是在你上一次和 Subversion 服务器通讯时同步了之后，离线运行的 ","l":"\n","c":[{"n":"code","x":"blame","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"log","l":" 命令。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","忽略 Subversion 所忽略的"]],"c":[{"n":"h5","x":"忽略 Subversion 所忽略的","l":"\n","a":[["id","_忽略_subversion_所忽略的"]]},{"n":"p","x":"如果克隆一个在任意一处设置 ","l":"\n","c":[{"n":"code","x":"svn:ignore","l":" 属性的 Subversion 仓库时，你也许会想要设置对应的 ","a":[["class","literal"]]},{"n":"code","x":".gitignore","l":" 文件，这样就不会意外的提交那些不该提交的文件。\n","a":[["class","literal"]]},{"n":"code","x":"git svn","l":" 有两个命令来帮助解决这个问题。\n第一个是 ","a":[["class","literal"]]},{"n":"code","x":"git svn create-ignore","l":"，它会为你自动地创建对应的 ","a":[["class","literal"]]},{"n":"code","x":".gitignore","l":" 文件，这样你的下次提交就能包含它们。","a":[["class","literal"]]}]},{"n":"p","x":"第二个命令是 ","l":"\n","c":[{"n":"code","x":"git svn show-ignore","l":"，它会将你需要放在 ","a":[["class","literal"]]},{"n":"code","x":".gitignore","l":" 文件中的每行内容打印到标准输出，这样就可以将输出内容重定向到项目的例外文件中：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn show-ignore > .git/info/exclude","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这样，你就不会由于 ","l":"\n","c":[{"n":"code","x":".gitignore","l":" 文件而把项目弄乱。\n当你是 Subversion 团队中唯一的 Git 用户时这是一个好的选项，并且你的队友并不想要项目内存在 ","a":[["class","literal"]]},{"n":"code","x":".gitignore","l":" 文件。","a":[["class","literal"]]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git-Svn 总结"]],"c":[{"n":"h4","x":"Git-Svn 总结","l":"\n","a":[["id","_git_svn_总结"]]},{"n":"p","x":"当你不得不使用 Subversion 服务器或者其他必须运行一个 Subversion 服务器的开发环境时，","l":"\n","c":[{"n":"code","x":"git svn","l":" 工具很有用。\n你应该把它当做一个不完全的 Git，然而，你要是不用它的话，就会在做转换的过程中遇到很多麻烦的问题。\n为了不惹麻烦，尽量遵守这些准则：","a":[["class","literal"]]}]},{"n":"div","x":"\n","l":"\n","a":[["class","itemized-list"]],"c":[{"n":"ul","x":"\n","l":"\n","c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"保持一个线性的 Git 历史，其中不能有 ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":"git merge","l":" 生成的合并提交。\n把你在主线分支外开发的全部工作变基到主线分支；而不要合并入主线分支。","a":[["class","literal"]]}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"不要建立一个单独的 Git 服务器，也不要在 Git 服务器上协作。\n可以用一台 Git 服务器来帮助新来的开发者加速克隆，但是不要推送任何不包含 ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":"git-svn-id","l":" 条目的东西。\n你可能会需要增加一个 ","a":[["class","literal"]]},{"n":"code","x":"pre-receive","l":" 钩子来检查每一个提交信息是否包含 ","a":[["class","literal"]]},{"n":"code","x":"git-svn-id","l":" 并且拒绝任何未包含的提交。","a":[["class","literal"]]}]}]}]}]},{"n":"p","x":"如果你遵守了那些准则，忍受用一个 Subversion 服务器来工作可以更容易些。\n然而，如果有可能迁移到一个真正的 Git 服务器，那么迁移过去能使你的团队获得更多好处。","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Git 与 Mercurial"]],"c":[{"n":"h3","x":"Git 与 Mercurial","l":"\n","a":[["id","_git_与_mercurial"]]},{"n":"p","x":"\n\nDVCS 的宇宙里不只有 Git。\n实际上，在这个空间里有许多其他的系统。对于如何正确地进行分布式版本管理，每一个系统都有自己的视角。\n除了 Git，最流行的就是 Mercurial，并且它们两个在很多方面都很相似。","l":"\n"},{"n":"p","x":"好消息是，如果你更喜欢 Git 的客户端行为但是工作在源代码由 Mercurial 控制的项目中，有一种使用 Git 作为 Mercurial 托管仓库的客户端的方法。\n由于 Git 与服务器仓库是使用远程交互的，那么由远程助手实现的桥接方法就不会让人很惊讶。\n这个项目的名字是 git-remote-hg，可以在 ","l":"\n","c":[{"n":"a","x":"https://github.com/felipec/git-remote-hg","l":" 找到。","a":[["href","https://github.com/felipec/git-remote-hg"],["class","link"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","git-remote-hg"]],"c":[{"n":"h4","x":"git-remote-hg","l":"\n","a":[["id","_git_remote_hg"]]},{"n":"p","x":"首先，需要安装 git-remote-hg。\n实际上需要将它的文件放在 PATH 变量的某个目录中，像这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"curl -o ~/bin/git-remote-hg ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\\","l":"\n  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg\n","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"$ ","l":"chmod +x ~/bin/git-remote-hg","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"假定 ","l":"\n","c":[{"n":"code","x":"~/bin","l":" 在 ","a":[["class","literal"]]},{"n":"code","x":"$PATH","l":" 变量中。\nGit-remote-hg 有一个其他的依赖：","a":[["class","literal"]]},{"n":"code","x":"mercurial","l":" Python 库。\n如果已经安装了 Python，安装它就像这样简单：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"pip install mercurial","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"（如果未安装 Python，访问 ","l":"\n","c":[{"n":"a","x":"https://www.python.org/","l":" 来获取它。）","a":[["href","https://www.python.org/"],["class","link"]]}]},{"n":"p","x":"需要做的最后一件事是安装 Mercurial 客户端。\n如果还没有安装的话请访问 ","l":"\n","c":[{"n":"a","x":"https://www.mercurial-scm.org/","l":" 来安装。","a":[["href","https://www.mercurial-scm.org/"],["class","link"]]}]},{"n":"p","x":"现在已经准备好摇滚了。\n你所需要的一切就是一个你可以推送的 Mercurial 仓库。\n很幸运，每一个 Mercurial 仓库都可以这样做，所以我们只需要使用大家用来学习 Mercurial 的“hello world”仓库就可以了：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"hg clone http://selenic.com/repo/hello /tmp/hello","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","开始"]],"c":[{"n":"h4","x":"开始","l":"\n","a":[["id","_开始_2"]]},{"n":"p","x":"既然有一个可用的 “server-side” 仓库，我们可以通过一个典型的工作流来了解。\n你将会看到，这两种系统非常相似，没有太多的出入。","l":"\n"},{"n":"p","x":"和 Git 一样，首先我们克隆：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git clone hg::/tmp/hello /tmp/hello-git\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"cd /tmp/hello-git\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate\n* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile\n* 65bb417 Create a standard \"hello, world\" program","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"你会注意到与 Mercurial 仓库工作时使用了标准的 ","l":"\n","c":[{"n":"code","x":"git clone","l":" 命令。\n那是因为 git-remote-hg 工作在相当低的底层，使用类似于 Git HTTP/S 协议的机制实现的（远程助手）。\n由于 Git 与 Mercurial 都设计为每一个客户端有一个仓库的完整历史，所以这个命令做了一次完整的克隆，包括所有的项目历史，并且相当快地完成。","a":[["class","literal"]]}]},{"n":"p","x":"log 命令显示了两次提交，最后一次提交指向了一大堆引用。\n那说明这其中的一部分实际上并没有在那儿。\n让我们看看 ","l":"\n","c":[{"n":"code","x":".git","l":" 目录中实际上有什么：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"tree .git/refs\n.git/refs\n├── heads\n│   └── master\n├── hg\n│   └── origin\n│       ├── bookmarks\n│       │   └── master\n│       └── branches\n│           └── default\n├── notes\n│   └── hg\n├── remotes\n│   └── origin\n│       └── HEAD\n└── tags\n\n9 directories, 5 files","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"Git-remote-hg 尝试让结构更有 Git 风格，但是在隐藏在下面的是它管理两个轻微不同系统之间概念的映射。\n","l":"\n","c":[{"n":"code","x":"refs/hg","l":" 目录中存储了实际的远程引用。\n例如，","a":[["class","literal"]]},{"n":"code","x":"refs/hg/origin/branches/default","l":" 是一个包含以 “ac7955c” 开始的 SHA-1 值的 Git 引用文件，是 ","a":[["class","literal"]]},{"n":"code","x":"master","l":" 所指向的提交。\n所以 ","a":[["class","literal"]]},{"n":"code","x":"refs/hg","l":" 目录是一种类似 ","a":[["class","literal"]]},{"n":"code","x":"refs/remotes/origin","l":" 的替代品，但是它引入了书签与分支的区别。","a":[["class","literal"]]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"notes/hg","l":" 文件是 git-remote-hg 如何在 Git 的提交散列与 Mercurial 变更集 ID 之间建立映射的起点。\n让我们来探索一下：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"cat notes/hg\nd4c10386...\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git cat-file -p d4c10386...\ntree 1781c96...\nauthor remote-hg <> 1408066400 -0800\ncommitter remote-hg <> 1408066400 -0800\n\nNotes for master\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git ls-tree 1781c96...\n100644 blob ac9117f...\t65bb417...\n100644 blob 485e178...\tac7955c...\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git cat-file -p ac9117f\n0a04b987be5ae354b710cefeba0e2d9de7ad41a9","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"所以 ","l":"\n","c":[{"n":"code","x":"refs/notes/hg","l":" 指向了一个树，即在 Git 对象数据库中的一个有其他对象名字的列表。\n","a":[["class","literal"]]},{"n":"code","x":"git ls-tree","l":" 输出 tree 对象中所有项目的模式、类型、对象哈希与文件名。\n如果深入挖掘 tree 对象中的一个项目，我们会发现在其中是一个名字为 “ac9117f” 的 blob 对象（","a":[["class","literal"]]},{"n":"code","x":"master","l":" 所指向提交的 SHA-1 散列值），包含内容 “0a04b98” （是 ","a":[["class","literal"]]},{"n":"code","x":"default","l":" 分支指向的 Mercurial 变更集的 ID）。","a":[["class","literal"]]}]},{"n":"p","x":"好消息是大多数情况下我们不需要关心以上这些。\n典型的工作流程与使用 Git 远程仓库并没有什么不同。","l":"\n"},{"n":"p","x":"在我们继续之前，这里还有一件需要注意的事情：忽略。\nMercurial 与 Git 使用非常类似的机制实现这个功能，但是一般来说你不会想要把一个 ","l":"\n","c":[{"n":"code","x":".gitignore","l":" 文件提交到 Mercurial 仓库中。\n幸运的是，Git 有一种方式可以忽略本地磁盘仓库的文件，而且 Mercurial 格式是与 Git 兼容的，所以你只需将这个文件拷贝过去：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"cp .hgignore .git/info/exclude","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","l":"\n","c":[{"n":"code","x":".git/info/exclude","l":" 文件的作用像是一个 ","a":[["class","literal"]]},{"n":"code","x":".gitignore","l":"，但是它不包含在提交中。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","工作流程"]],"c":[{"n":"h4","x":"工作流程","l":"\n","a":[["id","_工作流程"]]},{"n":"p","x":"假设我们已经做了一些工作并且在 ","l":"\n","c":[{"n":"code","x":"master","l":" 分支做了几次提交，而且已经准备将它们推送到远程仓库。\n这是我们仓库现在的样子：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate\n* ba04a2a (HEAD, master) Update makefile\n* d25d16f Goodbye\n* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile\n* 65bb417 Create a standard \"hello, world\" program","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"我们的 ","l":"\n","c":[{"n":"code","x":"master","l":" 分支领先 ","a":[["class","literal"]]},{"n":"code","x":"origin/master","l":" 分支两个提交，但是那两个提交只存在于我们的本地机器中。\n让我们看看在同一时间有没有其他人做过什么重要的工作：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git fetch\nFrom hg::/tmp/hello\n   ac7955c..df85e87  master     -> origin/master\n   ac7955c..df85e87  branches/default -> origin/branches/default\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate --all\n* 7b07969 (refs/notes/hg) Notes for default\n* d4c1038 Notes for master\n* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation\n| * ba04a2a (HEAD, master) Update makefile\n| * d25d16f Goodbye\n|/\n* ac7955c Create a makefile\n* 65bb417 Create a standard \"hello, world\" program","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"因为使用了 ","l":"\n","c":[{"n":"code","x":"--all","l":" 标记，我们看到被 git-remote-hg 内部使用的 “notes” 引用，但是可以忽略它们。\n剩下的部分是我们期望的；","a":[["class","literal"]]},{"n":"code","x":"origin/master","l":" 已经前进了一次提交，同时我们的历史现在分叉了。\nMercurial 和我们本章中讨论的其他系统不一样，它能够处理合并，所以我们不需要做任何其他事情。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git merge origin/master\nAuto-merging hello.c\nMerge made by the 'recursive' strategy.\n hello.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate\n*   0c64627 (HEAD, master) Merge remote-tracking branch 'origin/master'\n|\\\n| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation\n* | ba04a2a Update makefile\n* | d25d16f Goodbye\n|/\n* ac7955c Create a makefile\n* 65bb417 Create a standard \"hello, world\" program","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"完美。\n运行测试然后所有测试都通过了，所以我们准备将工作共享给团队的其他成员。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git push\nTo hg::/tmp/hello\n   df85e87..0c64627  master -> master","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"就是这样！\n如果你现在查看一下 Mercurial 仓库，你会发现这样实现了我们所期望的：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"hg log -G --style compact\no    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben\n|\\     Merge remote-tracking branch 'origin/master'\n| |\n| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben\n| |    Update makefile\n| |\n| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben\n| |    Goodbye\n| |\n@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben\n|/     Add some documentation\n|\no  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm\n|    Create a makefile\n|\no  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm\n     Create a standard \"hello, world\" program","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"序号 ","l":"\n","c":[{"n":"em","x":"2","l":" 的变更集是由 Mercurial 生成的，序号 "},{"n":"em","x":"3","l":" 与序号 "},{"n":"em","x":"4","l":" 的变更集是由 git-remote-hg 生成的，通过 Git 推送上来的提交。"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","分支与书签"]],"c":[{"n":"h4","x":"分支与书签","l":"\n","a":[["id","_分支与书签"]]},{"n":"p","x":"Git 只有一种类型的分支：当提交生成时移动的一个引用。\n在 Mercurial 中，这种类型的引用叫作 “bookmark”，它的行为非常类似于 Git 分支。","l":"\n"},{"n":"p","x":"Mercurial 的 “branch” 概念则更重量级一些。\n变更集生成时的分支会记录 ","l":"\n","c":[{"n":"em","x":"在变更集中","l":"，意味着它会永远地存在于仓库历史中。\n这个例子描述了一个在 "},{"n":"code","x":"develop","l":" 分支上的提交：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"hg log -l 1\nchangeset:   6:8f65e5e02793\nbranch:      develop\ntag:         tip\nuser:        Ben Straub <ben@straub.cc>\ndate:        Thu Aug 14 20:06:38 2014 -0700\nsummary:     More documentation","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意开头为 “branch” 的那行。\nGit 无法真正地模拟这种行为（并且也不需要这样做；两种类型的分支都可以表达为 Git 的一个引用），但是 git-remote-hg 需要了解其中的区别，因为 Mercurial 关心。","l":"\n"},{"n":"p","x":"创建 Mercurial 书签与创建 Git 分支一样容易。\n在 Git 这边：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git checkout -b featureA\nSwitched to a new branch 'featureA'\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git push origin featureA\nTo hg::/tmp/hello\n * [new branch]      featureA -> featureA","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这就是所要做的全部。\n在 Mercurial 这边，它看起来像这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"hg bookmarks\n   featureA                  5:bd5ac26f11f9\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"hg log --style compact -G\n@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben\n|    More documentation\n|\no    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben\n|\\     Merge remote-tracking branch 'origin/master'\n| |\n| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben\n| |    update makefile\n| |\n| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben\n| |    goodbye\n| |\no |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben\n|/     Add some documentation\n|\no  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm\n|    Create a makefile\n|\no  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm\n     Create a standard \"hello, world\" program","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意在修订版本 5 上的新 ","l":"\n","c":[{"n":"code","x":"[featureA]","l":" 标签。\n在 Git 这边这些看起来像是 Git 分支，除了一点：不能从 Git 这边删除书签（这是远程助手的一个限制）。","a":[["class","literal"]]}]},{"n":"p","x":"你也可以工作在一个 “重量级” 的 Mercurial branch：只需要在 ","l":"\n","c":[{"n":"code","x":"branches","l":" 命名空间内创建一个分支：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git checkout -b branches/permanent\nSwitched to a new branch 'branches/permanent'\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"vi Makefile\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git commit -am ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'A permanent change'","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"$ ","l":"git push origin branches/permanent\nTo hg::/tmp/hello\n * [new branch]      branches/permanent -> branches/permanent","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"下面是 Mercurial 这边的样子：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"hg branches\npermanent                      7:a4529d07aad4\ndevelop                        6:8f65e5e02793\ndefault                        5:bd5ac26f11f9 (inactive)\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"hg log -G\no  changeset:   7:a4529d07aad4\n|  branch:      permanent\n|  tag:         tip\n|  parent:      5:bd5ac26f11f9\n|  user:        Ben Straub <ben@straub.cc>\n|  date:        Thu Aug 14 20:21:09 2014 -0700\n|  summary:     A permanent change\n|\n| @  changeset:   6:8f65e5e02793\n|/   branch:      develop\n|    user:        Ben Straub <ben@straub.cc>\n|    date:        Thu Aug 14 20:06:38 2014 -0700\n|    summary:     More documentation\n|\no    changeset:   5:bd5ac26f11f9\n|\\   bookmark:    featureA\n| |  parent:      4:0434aaa6b91f\n| |  parent:      2:f098c7f45c4f\n| |  user:        Ben Straub <ben@straub.cc>\n| |  date:        Thu Aug 14 20:02:21 2014 -0700\n| |  summary:     Merge remote-tracking branch 'origin/master'\n[...]","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"分支名字 “permanent” 记录在序号 ","l":"\n","c":[{"n":"em","x":"7","l":" 的变更集中。"}]},{"n":"p","x":"在 Git 这边，对于其中任何一种风格的分支的工作都是相同的：仅仅是正常做的检出、提交、抓取、合并、拉取与推送。\n还有需要知道的一件事情是 Mercurial 不支持重写历史，只允许添加历史。\n下面是我们的 Mercurial 仓库在交互式的变基与强制推送后的样子：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"hg log --style compact -G\no  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben\n|    A permanent change\n|\no  9   f23e12f939c3   2014-08-14 20:01 -0700   ben\n|    Add some documentation\n|\no  8:1   c16971d33922   2014-08-14 20:00 -0700   ben\n|    goodbye\n|\n| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben\n| |    A permanent change\n| |\n| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben\n| |/     More documentation\n| |\n| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben\n| |\\     Merge remote-tracking branch 'origin/master'\n| | |\n| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben\n| | |    update makefile\n| | |\n+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben\n| |      goodbye\n| |\n| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben\n|/     Add some documentation\n|\no  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm\n|    Create a makefile\n|\no  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm\n     Create a standard \"hello, world\" program","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"变更集 ","l":"\n","c":[{"n":"em","x":"8","l":"、"},{"n":"em","x":"9","l":" 与 "},{"n":"em","x":"10","l":" 已经被创建出来并且属于 "},{"n":"code","x":"permanent","l":" 分支，但是旧的变更集依然在那里。\n这会让使用 Mercurial 的团队成员非常困惑，所以要避免这种行为。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Mercurial 总结"]],"c":[{"n":"h4","x":"Mercurial 总结","l":"\n","a":[["id","_mercurial_总结"]]},{"n":"p","x":"Git 与 Mercurial 如此相似，以至于跨这两个系统进行工作十分流畅。\n如果能注意避免改变在你机器上的历史（就像通常建议的那样），你甚至并不会察觉到另一端是 Mercurial。","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Git and Bazaar"]],"c":[{"n":"h3","x":"Git and Bazaar","l":"\n","a":[["id","_git_and_bazaar"]]},{"n":"p","x":"Among the DVCS, another famous one is ","l":"\n","c":[{"n":"a","x":"Bazaar","l":".\nBazaar is free and open source, and is part of the ","a":[["href","http://bazaar.canonical.com"],["class","link"]]},{"n":"a","x":"GNU Project","l":".\nIt behaves very differently from Git.\nSometimes, to do the same thing as with Git, you have to use a different keyword, and some keywords that are common don’t have the same meaning.\nIn particular, the branch management is very different and may cause confusion, especially when someone comes from Git’s universe.\nNevertheless, it is possible to work on a Bazaar repository from a Git one.","a":[["href","https://www.gnu.org"],["class","link"]]}]},{"n":"p","x":"There are many projects that allow you to use Git as a Bazaar client.\nHere we’ll use Felipe Contreras' project that you may find at ","l":"\n","c":[{"n":"a","x":"https://github.com/felipec/git-remote-bzr","l":".\nTo install it, you just have to download the file git-remote-bzr in a folder contained in your ","a":[["href","https://github.com/felipec/git-remote-bzr"],["class","link"]]},{"n":"code","x":"$PATH","l":":","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"wget https://raw.github.com/felipec/git-remote-bzr/master/git-remote-bzr -O ~/bin/git-remote-bzr\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"chmod +x ~/bin/git-remote-bzr","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"You also need to have Bazaar installed.\nThat’s all!","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Create a Git repository from a Bazaar repository"]],"c":[{"n":"h4","x":"Create a Git repository from a Bazaar repository","l":"\n","a":[["id","_create_a_git_repository_from_a_bazaar_repository"]]},{"n":"p","x":"It is simple to use.\nIt is enough to clone a Bazaar repository prefixing it by ","l":"\n","c":[{"n":"code","x":"bzr::","l":".\nSince Git and Bazaar both do full clones to your machine, it’s possible to attach a Git clone to your local Bazaar clone, but it isn’t recommended.\nIt’s much easier to attach your Git clone directly to the same place your Bazaar clone is attached to ‒ the central repository.","a":[["class","literal"]]}]},{"n":"p","x":"Let’s suppose that you worked with a remote repository which is at address ","l":"\n","c":[{"n":"code","x":"bzr+ssh://developer@mybazaarserver:myproject","l":".\nThen you must clone it in the following way:","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git clone bzr::bzr+ssh://developer@mybazaarserver:myproject myProject-Git\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"cd myProject-Git","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"At this point, your Git repository is created but it is not compacted for optimal disk use.\nThat’s why you should also clean and compact your Git repository, especially if it is a big one:","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git gc --aggressive","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Bazaar branches"]],"c":[{"n":"h4","x":"Bazaar branches","l":"\n","a":[["id","_bazaar_branches"]]},{"n":"p","x":"Bazaar only allows you to clone branches, but a repository may contain several branches, and ","l":"\n","c":[{"n":"code","x":"git-remote-bzr","l":" can clone both.\nFor example, to clone a branch:","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git clone bzr::bzr://bzr.savannah.gnu.org/emacs/trunk emacs-trunk","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"And to clone the whole repository:","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git clone bzr::bzr://bzr.savannah.gnu.org/emacs emacs","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"The second command clones all the branches contained in the emacs repository; nevertheless, it is possible to point out some branches:","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git config remote-bzr.branches ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'trunk, xwindow'","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"Some remote repositories don’t allow you to list their branches, in which case you have to manually specify them, and even though you could specify the configuration in the cloning command, you may find this easier:","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git init emacs\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git remote add origin bzr::bzr://bzr.savannah.gnu.org/emacs\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git config remote-bzr.branches ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'trunk, xwindow'","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"$ ","l":"git fetch","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Ignore what is ignored with .bzrignore"]],"c":[{"n":"h4","x":"Ignore what is ignored with .bzrignore","l":"\n","a":[["id","_ignore_what_is_ignored_with_bzrignore"]]},{"n":"p","x":"Since you are working on a project managed with Bazaar, you shouldn’t create a ","l":"\n","c":[{"n":"code","x":".gitignore","l":" file because you ","a":[["class","literal"]]},{"n":"em","x":"may","l":" accidentally set it under version control and the other people working with Bazaar would be disturbed.\nThe solution is to create the "},{"n":"code","x":".git/info/exclude","l":" file either as a symbolic link or as a regular file.\nWe’ll see later on how to solve this question.","a":[["class","literal"]]}]},{"n":"p","x":"Bazaar uses the same model as Git to ignore files, but also has two features which don’t have an equivalent into Git.\nThe complete description may be found in ","l":"\n","c":[{"n":"a","x":"the documentation","l":".\nThe two features are:","a":[["href","http://doc.bazaar.canonical.com/bzr.2.7/en/user-reference/ignore-help.html"],["class","link"]]}]},{"n":"div","x":"\n","l":"\n","a":[["class","ordered-list arabic"]],"c":[{"n":"ol","x":"\n","l":"\n","a":[["class","arabic"]],"c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"\"!!\" allows you to ignore certain file patterns even if they’re specified using a \"!\" rule.","l":"\n","a":[["class","principal"]]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"\"RE:\" at the beginning of a line allows you to specify a ","l":"\n","a":[["class","principal"]],"c":[{"n":"a","x":"Python regular expression","l":" (Git only allows shell globs).","a":[["href","https://docs.python.org/3/library/re.html"],["class","link"]]}]}]}]}]},{"n":"p","x":"As a consequence, there are two different situations to consider:","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","ordered-list arabic"]],"c":[{"n":"ol","x":"\n","l":"\n","a":[["class","arabic"]],"c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"If the ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":".bzrignore","l":" file does not contain any of these two specific prefixes, then you can simply make a symbolic link to it in the repository: ","a":[["class","literal"]]},{"n":"code","x":"ln -s .bzrignore .git/info/exclude","a":[["class","literal"]]}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"Otherwise, you must create the ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":".git/info/exclude","l":" file and adapt it to ignore exactly the same files in ","a":[["class","literal"]]},{"n":"code","x":".bzrignore","l":".","a":[["class","literal"]]}]}]}]}]},{"n":"p","x":"Whatever the case is, you will have to remain vigilant against any change of ","l":"\n","c":[{"n":"code","x":".bzrignore","l":" to make sure that the ","a":[["class","literal"]]},{"n":"code","x":".git/info/exclude","l":" file always reflects ","a":[["class","literal"]]},{"n":"code","x":".bzrignore","l":".\nIndeed, if the ","a":[["class","literal"]]},{"n":"code","x":".bzrignore","l":" file were to change and contained one or more lines starting with \"!!\" or \"RE:\", Git not being able to interpret these lines, you’ll have to adapt your ","a":[["class","literal"]]},{"n":"code","x":".git/info/exclude","l":" file to ignore the same files as the ones ignored with ","a":[["class","literal"]]},{"n":"code","x":".bzrignore","l":".\nMoreover, if the ","a":[["class","literal"]]},{"n":"code","x":".git/info/exclude","l":" file was a symbolic link, you’ll have to first delete the symbolic link, copy ","a":[["class","literal"]]},{"n":"code","x":".bzrignore","l":" to ","a":[["class","literal"]]},{"n":"code","x":".git/info/exclude","l":" and then adapt the latter.\nHowever, be careful with its creation because with Git it is impossible to re-include a file if a parent directory of that file is excluded.","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Fetch the changes of the remote repository"]],"c":[{"n":"h4","x":"Fetch the changes of the remote repository","l":"\n","a":[["id","_fetch_the_changes_of_the_remote_repository"]]},{"n":"p","x":"To fetch the changes of the remote, you pull changes as usually, using Git commands.\nSupposing that your changes are on the ","l":"\n","c":[{"n":"code","x":"master","l":" branch, you merge or rebase your work on the ","a":[["class","literal"]]},{"n":"code","x":"origin/master","l":" branch:","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git pull --rebase origin","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Push your work on the remote repository"]],"c":[{"n":"h4","x":"Push your work on the remote repository","l":"\n","a":[["id","_push_your_work_on_the_remote_repository"]]},{"n":"p","x":"Because Bazaar also has the concept of merge commits, there will be no problem if you push a merge commit.\nSo you can work on a branch, merge the changes into ","l":"\n","c":[{"n":"code","x":"master","l":" and push your work.\nThen, you create your branches, you test and commit your work as usual.\nYou finally push your work to the Bazaar repository:","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git push origin master","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Caveats"]],"c":[{"n":"h4","x":"Caveats","l":"\n","a":[["id","_caveats"]]},{"n":"p","x":"Git’s remote-helpers framework has some limitations that apply.\nIn particular, these commands don’t work:","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","itemized-list"]],"c":[{"n":"ul","x":"\n","l":"\n","c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"git push origin :branch-to-delete (Bazaar can’t accept ref deletions in this way.)","l":"\n","a":[["class","principal"]]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"git push origin old:new (it will push ","l":"\n","a":[["class","principal"]],"c":[{"n":"em","x":"old","l":")"}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"git push --dry-run origin branch (it will push)","l":"\n","a":[["class","principal"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Summary"]],"c":[{"n":"h4","x":"Summary","l":"\n","a":[["id","_summary"]]},{"n":"p","x":"Since Git’s and Bazaar’s models are similar, there isn’t a lot of resistance when working across the boundary.\nAs long as you watch out for the limitations, and are always aware that the remote repository isn’t natively Git, you’ll be fine.","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Git 与 Perforce"]],"c":[{"n":"h3","x":"Git 与 Perforce","l":"\n","a":[["id","_git_与_perforce"]]},{"n":"p","x":"\n\n在企业环境中 Perforce 是非常流行的版本管理系统。\n它大概起始于 1995 年，这使它成为了本章中介绍的最古老的系统。\n就其本身而言，它设计时带有当时时代的局限性；它假定你始终连接到一个单独的中央服务器，本地磁盘只保存一个版本。\n诚然，它的功能与限制适合几个特定的问题，但实际上，在很多情况下，将使用 Perforce 的项目换做使用 Git 会更好。","l":"\n"},{"n":"p","x":"如果你决定混合使用 Perforce 与 Git 这里有两种选择。\n第一个我们要介绍的是 Perforce 官方制作的 “Git Fusion” 桥接，它可以将 Perforce 仓库中的子树表示为一个可读写的 Git 仓库。\n第二个是 git-p4，一个客户端桥接允许你将 Git 作为 Perforce 的客户端使用，而不用在 Perforce 服务器上做任何重新的配置。","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git Fusion"]],"c":[{"n":"h4","x":"Git Fusion","l":"\n","a":[["id","_p4_git_fusion"]]},{"n":"p","x":"\nPerforce 提供了一个叫作 Git Fusion 的产品（可在 ","l":"\n","c":[{"n":"a","x":"http://www.perforce.com/git-fusion","l":" 获得），它将会在服务器这边同步 Perforce 服务器与 Git 仓库。","a":[["href","http://www.perforce.com/git-fusion"],["class","link"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","设置"]],"c":[{"n":"h5","x":"设置","l":"\n","a":[["id","_设置_2"]]},{"n":"p","x":"针对我们的例子，我们将会使用最简单的方式安装 Git Fusion：下载一个虚拟机来运行 Perforce 守护进程与 Git Fusion。\n可以从 ","l":"\n","c":[{"n":"a","x":"http://www.perforce.com/downloads/Perforce/20-User","l":" 获得虚拟机镜像，下载完成后将它导入到你最爱的虚拟机软件中（我们将会使用 VirtualBox）。","a":[["href","http://www.perforce.com/downloads/Perforce/20-User"],["class","link"]]}]},{"n":"p","x":"在第一次启动机器后，它会询问你自定义三个 Linux 用户（","l":"\n","c":[{"n":"code","x":"root","l":"、","a":[["class","literal"]]},{"n":"code","x":"perforce","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"git","l":"）的密码，\n并且提供一个实例名字来区分在同一网络下不同的安装。当那些都完成后，将会看到这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","image"]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"img","l":"\n","a":[["src","images/git-fusion-boot.png"],["alt","Git Fusion 虚拟机启动屏幕。"],["data-calibre-src","OEBPS/images/git-fusion-boot.png"]]}]},{"n":"figcaption","x":"Figure 1. Git Fusion 虚拟机启动屏幕。","l":"\n"}]},{"n":"p","x":"应当注意显示在这儿的 IP 地址，我们将会在后面用到。\n接下来，我们将会创建一个 Perforce 用户。\n选择底部的 “Login” 选项并按下回车（或者用 SSH 连接到这台机器），然后登录为 ","l":"\n","c":[{"n":"code","x":"root","l":"。\n然后使用这些命令创建一个用户：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"p4 -p localhost:1666 -u super user -f john\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"p4 -p localhost:1666 -u john passwd\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"exit","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"第一个命令将会打开一个 VI 编辑器来自定义用户，但是可以通过输入 ","l":"\n","c":[{"n":"code","x":":wq","l":" 并回车来接受默认选项。\n第二个命令将会提示输入密码两次。\n这就是所有我们要通过终端提示符做的事情，所以现在可以退出当前会话了。","a":[["class","literal"]]}]},{"n":"p","x":"接下来要做的事就是告诉 Git 不要验证 SSL 证书。\nGit Fusion 镜像内置一个证书，但是域名并不匹配你的虚拟主机的 IP 地址，所以 Git 会拒绝 HTTPS 连接。\n如果要进行永久安装，查阅 Perforce Git Fusion 手册来安装一个不同的证书；然而，对于我们这个例子来说，这已经足够了。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"export GIT_SSL_NO_VERIFY=true","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在我们可以测试所有东西是不是正常工作。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git clone https://10.0.1.254/Talkhouse\nCloning into 'Talkhouse'...\nUsername for 'https://10.0.1.254': john\nPassword for 'https://john@10.0.1.254':\nremote: Counting objects: 630, done.\nremote: Compressing objects: 100% (581/581), done.\nremote: Total 630 (delta 172), reused 0 (delta 0)\nReceiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.\nResolving deltas: 100% (172/172), done.\nChecking connectivity... done.","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"虚拟机镜像自带一个可以克隆的样例项目。\n这里我们会使用之前创建的 ","l":"\n","c":[{"n":"code","x":"john","l":" 用户，通过 HTTPS 进行克隆；Git 询问此次连接的凭证，但是凭证缓存会允许我们跳过这步之后的任意后续请求。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","Fusion 配置"]],"c":[{"n":"h5","x":"Fusion 配置","l":"\n","a":[["id","_fusion_配置"]]},{"n":"p","x":"一旦安装了 Git Fusion，你会想要调整配置。\n使用你最爱的 Perforce 客户端做这件事实际上相当容易；只需要映射 Perforce 服务器上的 ","l":"\n","c":[{"n":"code","x":"//.git-fusion","l":" 目录到你的工作空间。\n文件结构看起来像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"tree\n.\n├── objects\n│   ├── repos\n│   │   └── [...]\n│   └── trees\n│       └── [...]\n│\n├── p4gf_config\n├── repos\n│   └── Talkhouse\n│       └── p4gf_config\n└── users\n    └── p4gf_usermap\n\n498 directories, 287 files","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"objects","l":" 目录被 Git Fusion 内部用来双向映射 Perforce 对象与 Git 对象，你不必弄乱那儿的任何东西。\n在这个目录中有一个全局的 ","a":[["class","literal"]]},{"n":"code","x":"p4gf_config","l":" 文件，每个仓库中也会有一份——这些配置文件决定了 Git Fusion 的行为。\n让我们看一下根目录下的文件：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ini"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"[repo-creation]","l":"\ncharset = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"utf8","l":"\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"[git-to-perforce]","l":"\nchange-owner = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"author","l":"\nenable-git-branch-creation = ","a":[["style","font-style: italic"]]},{"n":"span","x":"yes","l":"\nenable-swarm-reviews = ","a":[["style","font-style: italic"]]},{"n":"span","x":"yes","l":"\nenable-git-merge-commits = ","a":[["style","font-style: italic"]]},{"n":"span","x":"yes","l":"\nenable-git-submodules = ","a":[["style","font-style: italic"]]},{"n":"span","x":"yes","l":"\npreflight-commit = ","a":[["style","font-style: italic"]]},{"n":"span","x":"none","l":"\nignore-author-permissions = ","a":[["style","font-style: italic"]]},{"n":"span","x":"no","l":"\nread-permission-check = ","a":[["style","font-style: italic"]]},{"n":"span","x":"none","l":"\ngit-merge-avoidance-after-change-num = ","a":[["style","font-style: italic"]]},{"n":"span","x":"12107","l":"\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"[perforce-to-git]","l":"\nhttp-url = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"none","l":"\nssh-url = ","a":[["style","font-style: italic"]]},{"n":"span","x":"none","l":"\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"[@features]","l":"\nimports = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"False","l":"\nchunked-push = ","a":[["style","font-style: italic"]]},{"n":"span","x":"False","l":"\nmatrix2 = ","a":[["style","font-style: italic"]]},{"n":"span","x":"False","l":"\nparallel-push = ","a":[["style","font-style: italic"]]},{"n":"span","x":"False","l":"\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"[authentication]","l":"\nemail-case-sensitivity = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"no","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"这里我们并不会深入介绍这些选项的含义，但是要注意这是一个 INI 格式的文本文件，就像 Git 的配置。\n这个文件指定了全局选项，但它可以被仓库特定的配置文件覆盖，像是 ","l":"\n","c":[{"n":"code","x":"repos/Talkhouse/p4gf_config","l":"。\n如果打开这个文件，你会看到有一些与全局默认不同设置的 ","a":[["class","literal"]]},{"n":"code","x":"[@repo]","l":" 区块。\n你也会看到像下面这样的区块：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ini"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"[Talkhouse-master]","l":"\ngit-branch-name = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"master","l":"\nview = ","a":[["style","font-style: italic"]]},{"n":"span","x":"//depot/Talkhouse/main-dev/... ...","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"这是一个 Perforce 分支与一个 Git 分支的映射。\n这个区块可以被命名成你喜欢的名字，只要保证名字是唯一的即可。\n","l":"\n","c":[{"n":"code","x":"git-branch-name","l":" 允许你将在 Git 下显得笨重的仓库路径转换为更友好的名字。\n","a":[["class","literal"]]},{"n":"code","x":"view","l":" 选项使用标准视图映射语法控制 Perforce 文件如何映射到 Git 仓库。\n可以指定一个以上的映射，就像下面的例子：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ini"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"[multi-project-mapping]","l":"\ngit-branch-name = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"master","l":"\nview = ","a":[["style","font-style: italic"]]},{"n":"span","x":"//depot/project1/main/... project1/...","l":"\n       //depot/project2/mainline/... project2/...","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"通过这种方式，如果正常工作空间映射包含对目录结构的修改，可以将其复制为一个 Git 仓库。","l":"\n"},{"n":"p","x":"最后一个我们讨论的文件是 ","l":"\n","c":[{"n":"code","x":"users/p4gf_usermap","l":"，它将 Perforce 用户映射到 Git 用户，但你可能不会需要它。\n当从一个 Perforce 变更集转换为一个 Git 提交时，Git Fusion 的默认行为是去查找 Perforce 用户，然后把邮箱地址与全名存储在 Git 的 author/commiter 字段中。\n当反过来转换时，默认的行为是根据存储在 Git 提交中 author 字段中的邮箱地址来查找 Perforce 用户，然后以该用户提交变更集（以及权限的应用）。\n大多数情况下，这个行为工作得很好，但是考虑下面的映射文件：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"john john@example.com \"John Doe\"\njohn johnny@appleseed.net \"John Doe\"\nbob employeeX@example.com \"Anon X. Mouse\"\njoe employeeY@example.com \"Anon Y. Mouse\""}]}]},{"n":"p","x":"每一行的格式都是 ","l":"\n","c":[{"n":"code","x":"<user> <email> \"<full name>\"","l":"，创建了一个单独的用户映射。\n前两行映射不同的邮箱地址到同一个 Perforce 用户账户。\n当使用几个不同的邮箱地址（或改变邮箱地址）生成 Git 提交并且想要让他们映射到同一个 Perforce 用户时这会很有用。\n当从一个 Perforce 变更集创建一个 Git 提交时，第一个匹配 Perforce 用户的行会被用作 Git 作者信息。","a":[["class","literal"]]}]},{"n":"p","x":"最后两行从创建的 Git 提交中掩盖了 Bob 与 Joe 的真实名字与邮箱地址。\n当你想要将一个内部项目开源，但不想将你的雇员目录公布到全世界时这很不错。\n注意邮箱地址与全名需要是唯一的，除非想要所有的 Git 提交都属于一个虚构的作者。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","工作流程"]],"c":[{"n":"h5","x":"工作流程","l":"\n","a":[["id","_工作流程_2"]]},{"n":"p","x":"Perforce Git Fusion 是在 Perforce 与 Git 版本控制间双向的桥接。\n让我们看一下在 Git 这边工作是什么样的感觉。\n假定我们在 “Jam” 项目中使用上述的配置文件映射了，可以这样克隆：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git clone https://10.0.1.254/Jam\nCloning into 'Jam'...\nUsername for 'https://10.0.1.254': john\nPassword for 'https://john@10.0.1.254':\nremote: Counting objects: 2070, done.\nremote: Compressing objects: 100% (1704/1704), done.\nReceiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.\nremote: Total 2070 (delta 1242), reused 0 (delta 0)\nResolving deltas: 100% (1242/1242), done.\nChecking connectivity... done.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git branch -a\n* master\n  remotes/origin/HEAD -> origin/master\n  remotes/origin/master\n  remotes/origin/rel2.1\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --decorate --graph --all\n* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.\n| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.\n| * bd2f54a Put in fix for jam's NT handle leak.\n| * c0f29e7 Fix URL in a jam doc\n| * cc644ac Radstone's lynx port.\n[...]","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"当首次这样做时，会花费一些时间。\n这里发生的是 Git Fusion 会将在 Perforce 历史中所有合适的变更集转换为 Git 提交。\n这发生在服务器端本地，所以会相当快，但是如果有很多历史，那么它还是会花费一些时间。\n后来的抓取会做增量转换，所以会感觉更像 Git 的本地速度。","l":"\n"},{"n":"p","x":"如你所见，我们的仓库看起来像之前使用过的任何一个 Git 仓库了。\n这里有三个分支，Git 已经帮助创建了一个跟踪 ","l":"\n","c":[{"n":"code","x":"origin/master","l":" 的本地 ","a":[["class","literal"]]},{"n":"code","x":"master","l":" 分支。\n让我们做一些工作，创建几个新提交：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"# ","l":"...\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --decorate --graph --all\n* cfd46ab (HEAD, master) Add documentation for new feature\n* a730d77 Whitespace\n* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.\n* bd2f54a Put in fix for jam's NT handle leak.\n[...]","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"我们有两个新提交。\n现在我们检查下是否有其他人在工作：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git fetch\nremote: Counting objects: 5, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 3 (delta 2), reused 0 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://10.0.1.254/Jam\n   d254865..6afeb15  master     -> origin/master\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --decorate --graph --all\n* 6afeb15 (origin/master, origin/HEAD) Update copyright\n| * cfd46ab (HEAD, master) Add documentation for new feature\n| * a730d77 Whitespace\n|/\n* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.\n* bd2f54a Put in fix for jam's NT handle leak.\n[...]","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"看起来有人在工作！\n从这个视图来看你并不知道这点，但是 ","l":"\n","c":[{"n":"code","x":"6afeb15","l":" 提交确实是使用 Perforce 客户端创建的。\n从 Git 的视角看它仅仅只是另一个提交，准确地说是一个点。\n让我们看看 Perforce 服务器如何处理一个合并提交：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git merge origin/master\nAuto-merging README\nMerge made by the 'recursive' strategy.\n README | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git push\nCounting objects: 9, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (9/9), done.\nWriting objects: 100% (9/9), 917 bytes | 0 bytes/s, done.\nTotal 9 (delta 6), reused 0 (delta 0)\nremote: Perforce: 100% (3/3) Loading commit tree into memory...\nremote: Perforce: 100% (5/5) Finding child commits...\nremote: Perforce: Running git fast-export...\nremote: Perforce: 100% (3/3) Checking commits...\nremote: Processing will continue even if connection is closed.\nremote: Perforce: 100% (3/3) Copying changelists...\nremote: Perforce: Submitting new Git commit objects to Perforce: 4\nTo https://10.0.1.254/Jam\n   6afeb15..89cba2b  master -> master","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"Git 认为它成功了。\n让我们从 Perforce 的视角看一下 ","l":"\n","c":[{"n":"code","x":"README","l":" 文件的历史，使用 ","a":[["class","literal"]]},{"n":"code","x":"p4v","l":" 的版本图功能。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","image"]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"img","l":"\n","a":[["src","images/git-fusion-perforce-graph.png"],["alt","Git 推送后的 Perforce 版本图。"],["data-calibre-src","OEBPS/images/git-fusion-perforce-graph.png"]]}]},{"n":"figcaption","x":"Figure 2. Git 推送后的 Perforce 版本图","l":"\n"}]},{"n":"p","x":"如果你在之前从未看过这个视图，它似乎让人困惑，但是它显示出了作为 Git 历史图形化查看器相同的概念。\n我们正在查看 ","l":"\n","c":[{"n":"code","x":"README","l":" 文件的历史，所以左上角的目录树只显示那个文件在不同分支的样子。\n右上方，我们有不同版本文件关系的可视图，这个可视图的全局视图在右下方。\n视图中剩余的部分显示出选择版本的详细信息（在这个例子中是 ","a":[["class","literal"]]},{"n":"code","x":"2","l":"）","a":[["class","literal"]]}]},{"n":"p","x":"还要注意的一件事是这个图看起来很像 Git 历史中的图。\nPerforce 没有存储 ","l":"\n","c":[{"n":"code","x":"1","l":" 和 ","a":[["class","literal"]]},{"n":"code","x":"2","l":" 提交的命名分支，所以它在 ","a":[["class","literal"]]},{"n":"code","x":".git-fusion","l":" 目录中生成了一个 “anonymous” 分支来保存它。\n这也会在 Git 命名分支不对应 Perforce 命名分支时发生（稍后你可以使用配置文件来映射它们到 Perforce 分支）。","a":[["class","literal"]]}]},{"n":"p","x":"这些大多数发生在后台，但是最终结果是团队中的一个人可以使用 Git，另一个可以使用 Perforce，而所有人都不知道其他人的选择。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","Git-Fusion 总结"]],"c":[{"n":"h5","x":"Git-Fusion 总结","l":"\n","a":[["id","_git_fusion_总结"]]},{"n":"p","x":"如果你有（或者能获得）接触你的 Perforce 服务器的权限，那么 Git Fusion 是使 Git 与 Perforce 互相交流的很好的方法。\n这里包含了一点配置，但是学习曲线并不是很陡峭。\n这是本章中其中一个不会出现无法使用 Git 全部能力的警告的章节。\n这并不是说扔给 Perforce 任何东西都会高兴——如果你尝试重写已经推送的历史，Git Fusion 会拒绝它——虽然 Git Fusion 尽力让你感觉是原生的。\n你甚至可以使用 Git 子模块（尽管它们对 Perforce 用户看起来很奇怪），合并分支（在 Perforce 这边会被记录了一次整合）。","l":"\n"},{"n":"p","x":"如果不能说服你的服务器管理员设置 Git Fusion，依然有一种方式来一起使用这两个工具。","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git-p4"]],"c":[{"n":"h4","x":"Git-p4","l":"\n","a":[["id","_git_p4_client"]]},{"n":"p","x":"\nGit-p4 是 Git 与 Perforce 之间的双向桥接。\n它完全运行在你的 Git 仓库内，所以你不需要任何访问 Perforce 服务器的权限（当然除了用户验证）。\nGit-p4 并不像 Git Fusion 一样灵活或完整，但是它允许你在无需修改服务器环境的情况下，做大部分想做的事情。","l":"\n"},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"为了与 git-p4 一起工作需要在你的 ","l":"\n","c":[{"n":"code","x":"PATH","l":" 环境变量中的某个目录中有 ","a":[["class","literal"]]},{"n":"code","x":"p4","l":" 工具。\n在写这篇文章的时候，它可以在 ","a":[["class","literal"]]},{"n":"a","x":"http://www.perforce.com/downloads/Perforce/20-User","l":" 免费获得。","a":[["href","http://www.perforce.com/downloads/Perforce/20-User"],["class","link"]]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","设置"]],"c":[{"n":"h5","x":"设置","l":"\n","a":[["id","_设置_3"]]},{"n":"p","x":"出于演示的目的，我们将会从上面演示的 Git Fusion OVA 运行 Perforce 服务器，但是我们会绕过 Git Fusion 服务器然后直接进行 Perforce 版本管理。","l":"\n"},{"n":"p","x":"为了使用 ","l":"\n","c":[{"n":"code","x":"p4","l":" 命令行客户端（git-p4 依赖项），你需要设置两个环境变量：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"export P4PORT=10.0.1.254:1666\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"export P4USER=john","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","开始"]],"c":[{"n":"h5","x":"开始","l":"\n","a":[["id","_开始_3"]]},{"n":"p","x":"像在 Git 中的任何事情一样，第一个命令就是克隆：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git p4 clone //depot/www/live www-shallow\nImporting from //depot/www/live into www-shallow\nInitialized empty Git repository in /private/tmp/www-shallow/.git/\nDoing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这样会创建出一种在 Git 中名为 “shallow” 的克隆；只有最新版本的 Perforce 被导入至 Git；记住，Perforce 并未被设计成给每一个用户一个版本。\n使用 Git 作为 Perforce 客户端这样就足够了，但是为了其他目的的话这样可能不够。","l":"\n"},{"n":"p","x":"完成之后，我们就有一个全功能的 Git 仓库：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"cd myproject\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --all --graph --decorate\n* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意有一个 “p4” 远程代表 Perforce 服务器，但是其他东西看起来就像是标准的克隆。\n实际上，这有一点误导：其实远程仓库并不存在。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git remote -v","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"在当前仓库中并不存在任何远程仓库。\nGit-p4 创建了一些引用来代表服务器的状态，它们看起来类似 ","l":"\n","c":[{"n":"code","x":"git log","l":" 显示的远程引用，但是它们并不被 Git 本身管理，并且你无法推送它们。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","工作流程"]],"c":[{"n":"h5","x":"工作流程","l":"\n","a":[["id","_工作流程_3"]]},{"n":"p","x":"好了，让我们开始一些工作。\n假设你已经在一个非常重要的功能上做了一些工作，然后准备好将它展示给团队中的其他人。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log --oneline --all --graph --decorate\n* 018467c (HEAD, master) Change page title\n* c0fb617 Update link\n* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"我们已经生成了两次新提交并已准备好推送它们到 Perforce 服务器。\n让我们检查一下今天其他人是否做了一些工作：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git p4 sync\ngit p4 sync\nPerforming incremental import into refs/remotes/p4/master git branch\nDepot paths: //depot/www/live/\nImport destination: refs/remotes/p4/master\nImporting revision 12142 (100%)\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --all --graph --decorate\n* 75cd059 (p4/master, p4/HEAD) Update copyright\n| * 018467c (HEAD, master) Change page title\n| * c0fb617 Update link\n|/\n* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"看起来他们做了，","l":"\n","c":[{"n":"code","x":"master","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"p4/master","l":" 已经分叉了。\nPerforce 的分支系统一点也 ","a":[["class","literal"]]},{"n":"em","x":"不","l":" 像 Git 的，所以提交合并提交没有任何意义。\nGit-p4 建议变基你的提交，它甚至提供了一个快捷方式来这样做："}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git p4 rebase\nPerforming incremental import into refs/remotes/p4/master git branch\nDepot paths: //depot/www/live/\nNo changes to import!\nRebasing the current branch onto remotes/p4/master\nFirst, rewinding head to replay your work on top of it...\nApplying: Update link\nApplying: Change page title\n index.html | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"从输出中可能大概得知，","l":"\n","c":[{"n":"code","x":"git p4 rebase","l":" 是 ","a":[["class","literal"]]},{"n":"code","x":"git p4 sync","l":" 接着 ","a":[["class","literal"]]},{"n":"code","x":"git rebase p4/master","l":" 的快捷方式。\n它比那更聪明一些，特别是工作在多个分支时，但这是一个进步。","a":[["class","literal"]]}]},{"n":"p","x":"现在我们的历史再次是线性的，我们准备好我们的改动贡献回 Perforce。\n","l":"\n","c":[{"n":"code","x":"git p4 submit","l":" 命令会尝试在 ","a":[["class","literal"]]},{"n":"code","x":"p4/master","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"master","l":" 之间的每一个 Git 提交创建一个新的 Perforce 修订版本。\n运行它会带我们到最爱的编辑器，文件内容看起来像是这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"# ","l":"A Perforce Change Specification.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#","l":"\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#  ","l":"Change:      The change number. ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'new'","l":" on a new changelist.\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#  ","l":"Date:        The date this specification was last modified.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#  ","l":"Client:      The client on which the changelist was created.  Read-only.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#  ","l":"User:        The user who created the changelist.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#  ","l":"Status:      Either ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'pending'","l":" or ","a":[["style","font-style: italic"]]},{"n":"span","x":"'submitted'","l":". Read-only.\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#  ","l":"Type:        Either ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'public'","l":" or ","a":[["style","font-style: italic"]]},{"n":"span","x":"'restricted'","l":". Default is ","a":[["style","font-style: italic"]]},{"n":"span","x":"'public'","l":".\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#  ","l":"Description: Comments about the changelist.  Required.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#  ","l":"Jobs:        What opened jobs are to be closed by this changelist.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#               ","l":"You may delete jobs from this list.  (New changelists only.)\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#  ","l":"Files:       What opened files from the default changelist are to be added\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#               ","l":"to this changelist.  You may delete files from this list.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#               ","l":"(New changelists only.)\n\nChange:  new\n\nClient:  john_bens-mbp_8487\n\nUser: john\n\nStatus:  new\n\nDescription:\n   Update link\n\nFiles:\n   //depot/www/live/index.html   # edit\n\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#","a":[["style","font-weight: bold"]]},{"n":"span","x":"####### git author ben@straub.cc does not match your p4 account.","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#","a":[["style","font-weight: bold"]]},{"n":"span","x":"####### Use option --preserve-user to modify authorship.","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#","a":[["style","font-weight: bold"]]},{"n":"span","x":"####### Variable git-p4.skipUserNameCheck hides this message.","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#","a":[["style","font-weight: bold"]]},{"n":"span","x":"####### everything below this line is just the diff #######","l":"\n--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000\n+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000\n@@ -60,7 +60,7 @@\n </td>\n <td valign=top>\n Source and documentation for\n-<a href=\"http://www.perforce.com/jam/jam.html\">\n+<a href=\"jam.html\">\n Jam/MR</a>,\n a software build tool.\n </td>","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"除了结尾 git-p4 给我们的帮助性的提示，其它的与你运行 ","l":"\n","c":[{"n":"code","x":"p4 submit","l":" 后看到的内容大多相同。\n当提交或变更集需要一个名字时 git-p4 会分别尝试使用你的 Git 与 Perforce 设置，但是有些情况下你会想要覆盖默认行为。\n例如，如果你正导入的提交是由没有 Perforce 用户账户的贡献者编写的，你还是会想要最终的变更集看起来像是他们写的（而不是你）。","a":[["class","literal"]]}]},{"n":"p","x":"Git-p4 帮助性地将 Git 的提交注释导入到 Perforce 变更集的内容，这样所有我们必须做的就是保存并退出，两次（每次一个提交）。\n这会使 shell 输出看起来像这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git p4 submit\nPerforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/\nSynchronizing p4 checkout...\n... - file(s) up-to-date.\nApplying dbac45b Update link\n//depot/www/live/index.html#4 - opened for edit\nChange 12143 created with 1 open file(s).\nSubmitting change 12143.\nLocking 1 files ...\nedit //depot/www/live/index.html#5\nChange 12143 submitted.\nApplying 905ec6a Change page title\n//depot/www/live/index.html#5 - opened for edit\nChange 12144 created with 1 open file(s).\nSubmitting change 12144.\nLocking 1 files ...\nedit //depot/www/live/index.html#6\nChange 12144 submitted.\nAll commits applied!\nPerforming incremental import into refs/remotes/p4/master git branch\nDepot paths: //depot/www/live/\nImport destination: refs/remotes/p4/master\nImporting revision 12144 (100%)\nRebasing the current branch onto remotes/p4/master\nFirst, rewinding head to replay your work on top of it...\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --all --graph --decorate\n* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title\n* 05f1ade Update link\n* 75cd059 Update copyright\n* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"结果恰如我们只是做了一次 ","l":"\n","c":[{"n":"code","x":"git push","l":"，就像是应当实际发生的最接近的类比。","a":[["class","literal"]]}]},{"n":"p","x":"注意在这个过程中每一个 Git 提交都会被转化为一个 Perforce 变更集。\n如果想要将它们压缩成为一个单独的提交，可以在运行 ","l":"\n","c":[{"n":"code","x":"git p4 submit","l":" 前进行一次交互式变基。\n同样注意的是所有被转化为变更集的提交的 SHA-1 校验和都改变了，\n这是因为 git-p4 在每一个转化的提交增加一行到提交注释结尾：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log -1\ncommit 775a46f630d8b46535fc9983cf3ebe6b9aa53145\nAuthor: John Doe <john@example.com>\nDate:   Sun Aug 31 10:31:44 2014 -0800\n\n    Change page title\n\n    [git-p4: depot-paths = \"//depot/www/live/\": change = 12144]","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"当尝试提交一次合并提交时会发生什么？\n让我们尝试一下。\n这是我们可能会遇到的一种情形：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log --oneline --all --graph --decorate\n* 3be6fd8 (HEAD, master) Correct email address\n*   1dcbf21 Merge remote-tracking branch 'p4/master'\n|\\\n| * c4689fc (p4/master, p4/HEAD) Grammar fix\n* | cbacd0a Table borders: yes please\n* | b4959b6 Trademark\n|/\n* 775a46f Change page title\n* 05f1ade Update link\n* 75cd059 Update copyright\n* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"Git 与 Perforce 历史在 775a46f 后分叉了。\nGit 这边有两次提交，然后一次与 Perforce 头部的合并提交，还有另一个提交。\n我们将会尝试提交这些到 Perforce 那边单独的变更集之上。\n让我们看看如果尝试这样提交会发生什么：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git p4 submit -n\nPerforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/\nWould synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/\nWould apply\n  b4959b6 Trademark\n  cbacd0a Table borders: yes please\n  3be6fd8 Correct email address","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"-n","l":" 标记是 ","a":[["class","literal"]]},{"n":"code","x":"--dry-run","l":" 的缩写，将会报告如果提交命令真的运行会发生什么。\n这本例中，它看起来像是我们会创建三个 Perforce 变更集，对应着不在 Perforce 服务器端的三次非合并提交。\n那听起来像是我们想要的，让我们看看它会如何做：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git p4 submit\n[…]\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --all --graph --decorate\n* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address\n* 1b79a80 Table borders: yes please\n* 0097235 Trademark\n* c4689fc Grammar fix\n* 775a46f Change page title\n* 05f1ade Update link\n* 75cd059 Update copyright\n* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"我们的历史变成线性了，就像在提交前刚刚变基过（实际上也是这样）。\n这意味着你可以在 Git 这边自由地创建、工作、扔掉与合并分支而不用害怕你的历史会变得与 Perforce 不兼容。\n如果你可以变基它，你就可以将它贡献到 Perforce 服务器。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect4"],["title","分支"]],"c":[{"n":"h5","x":"分支","l":"\n","a":[["id","_git_p4_branches"]]},{"n":"p","x":"如果你的 Perforce 项目有多个分支，你并不会不走运；git-p4 可以以一种类似 Git 的方式来处理那种情况。\n假定你的 Perforce 仓库平铺的时候像这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"//depot\n  └── project\n      ├── main\n      └── dev"}]}]},{"n":"p","x":"并且假定你有一个 ","l":"\n","c":[{"n":"code","x":"dev","l":" 分支，有一个视图规格像下面这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"//depot/project/main/... //depot/project/dev/..."}]}]},{"n":"p","x":"Git-p4 可以自动地检测到这种情形并做正确的事情：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git p4 clone --detect-branches //depot/project@all\nImporting from //depot/project@all into project\nInitialized empty Git repository in /private/tmp/project/.git/\nImporting revision 20 (50%)\n    Importing new branch project/dev\n\n    Resuming with change 20\nImporting revision 22 (100%)\nUpdated branches: main dev\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"cd project; git log --oneline --all --graph --decorate\n* eae77ae (HEAD, p4/master, p4/HEAD, master) main\n| * 10d55fb (p4/project/dev) dev\n| * a43cfae Populate //depot/project/main/... //depot/project/dev/....\n|/\n* 2b83451 Project init","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意在仓库路径中的 “@all” 说明符；那会告诉 git-p4 不仅仅只是克隆那个子树最新的变更集，更包括那些路径未接触的所有变更集。\n这有点类似于 Git 的克隆概念，但是如果你工作在一个具有很长历史的项目，那么它会花费一段时间。","l":"\n"},{"n":"p","l":"\n","c":[{"n":"code","x":"--detect-branches","l":" 标记告诉 git-p4 使用 Perforce 的分支规范来映射到 Git 的引用中。\n如果这些映射不在 Perforce 服务器中（使用 Perforce 的一种完美有效的方式），你可以告诉 git-p4 分支映射是什么，然后你会得到同样的结果：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git init project\nInitialized empty Git repository in /tmp/project/.git/\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"cd project\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git config git-p4.branchList main:dev\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git clone --detect-branches //depot/project@all .","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"设置 ","l":"\n","c":[{"n":"code","x":"git-p4.branchList","l":" 配置选项为 ","a":[["class","literal"]]},{"n":"code","x":"main:dev","l":" 告诉 git-p4 那个 “main” 与 “dev” 都是分支，第二个是第一个的子分支。","a":[["class","literal"]]}]},{"n":"p","x":"如果我们现在运行 ","l":"\n","c":[{"n":"code","x":"git checkout -b dev p4/project/dev","l":" 并且做一些提交，在运行 ","a":[["class","literal"]]},{"n":"code","x":"git p4 submit","l":" 时 git-p4 会聪明地选择正确的分支。\n不幸的是，git-p4 不能混用 shallow 克隆与多个分支；如果你有一个巨型项目并且想要同时工作在不止一个分支上，可能不得不针对每一个你想要提交的分支运行一次 ","a":[["class","literal"]]},{"n":"code","x":"git p4 clone","l":"。","a":[["class","literal"]]}]},{"n":"p","x":"为了创建与整合分支，你不得不使用一个 Perforce 客户端。\nGit-p4 只能同步或提交已有分支，并且它一次只能做一个线性的变更集。\n如果你在 Git 中合并两个分支并尝试提交新的变更集，所有这些会被记录为一串文件修改；关于哪个分支参与的元数据在整合中会丢失。","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git 与 Perforce 总结"]],"c":[{"n":"h4","x":"Git 与 Perforce 总结","l":"\n","a":[["id","_git_与_perforce_总结"]]},{"n":"p","x":"Git-p4 将与 Perforce 服务器工作时使用 Git 工作流成为可能，并且它非常擅长这点。\n然而，需要记住的重要一点是 Perforce 负责源头，而你只是在本地使用 Git。\n在共享 Git 提交时要相当小心：如果你有一个其他人使用的远程仓库，不要在提交到 Perforce 服务器前推送任何提交。","l":"\n"},{"n":"p","x":"如果想要为源码管理自由地混合使用 Perforce 与 Git 作为客户端，可以说服服务器管理员安装 Git Fusion，Git Fusion 使 Git 作为 Perforce 服务器的首级版本管理客户端。","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Git 与 TFS"]],"c":[{"n":"h3","x":"Git 与 TFS","l":"\n","a":[["id","_git_与_tfs"]]},{"n":"p","x":"\n\nGit 在 Windows 开发者当中变得流行起来，如果你正在 Windows 上编写代码并且正在使用 Microsoft 的 Team Foundation Server （TFS），这会是个好机会。\nTFS 是一个包含工作项目检测与跟踪、支持 Scrum 与其他流程管理方法、代码审核、版本控制的协作套件。\n这里有一点困惑：","l":"\n","c":[{"n":"strong","x":"TFS","l":" 是服务器，它支持通过 Git 与它们自定义的 VCS 来管理源代码，这被他们称为 "},{"n":"strong","x":"TFVC","l":"（Team Foundation Version Control）。\nGit 支持 TFS（自 2013 版本起）的部分新功能，所以在那之前所有工具都将版本控制部分称为 “TFS”，即使实际上他们大部分时间都在与 TFVC 工作。"}]},{"n":"p","x":"如果发现你的团队在使用 TFVC 但是你更愿意使用 Git 作为版本控制客户端，这里为你准备了一个项目。","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","选择哪个工具"]],"c":[{"n":"h4","x":"选择哪个工具","l":"\n","a":[["id","_选择哪个工具"]]},{"n":"p","x":"\n实际上，这里有两个工具：git-tf 与 git-tfs。","l":"\n"},{"n":"p","x":"Git-tfs （可以在 ","l":"\n","c":[{"n":"a","x":"https://github.com/git-tfs/git-tfs","l":" 找到）是一个 .NET 项目，它只能运行在 Windows 上（截至文章完成时）。\n为了操作 Git 仓库，它使用了 libgit2 的 .NET 绑定，一个可靠的面向库的 Git 实现，十分灵活且性能优越。\nLibgit2 并不是一个完整的 Git 实现，为了弥补差距 git-tfs 实际上会调用 Git 命令行客户端来执行某些操作，因此在操作 Git 仓库时并没有任何功能限制。\n因为它使用 Visual Studio 程序集对服务器进行操作，所以它对 TFVC 的支持非常成熟。\n这并不意味着你需要接触那些程序集，但是意味着你需要安装 Visual Studio 的一个最近版本（2010 之后的任何版本，包括 2012 之后的 Express 版本），或者 Visual Studio SDK。","a":[["href","https://github.com/git-tfs/git-tfs"],["class","link"]]}]},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition caution"],["title","Caution"],["type","warning",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"Git-tf 已经停止开发，它不会再得到任何更新。它也不再受到微软的支持。","l":"\n"}]}]},{"n":"p","x":"Git-tf（主页在 ","l":"\n","c":[{"n":"a","x":"https://archive.codeplex.com/?p=gittf","l":"）是一个 Java 项目，\n因此它可以运行在任何一个有 Java 运行时环境的电脑上。\n它通过 JGit（一个 Git 的 JVM 实现）来与 Git 仓库交互，这意味着事实上它没有 Git 功能上的限制。\n然而，相对于 git-tfs 它对 TFVC 的支持是有限的——例如，它不支持分支。","a":[["href","https://archive.codeplex.com/?p=gittf"],["class","link"]]}]},{"n":"p","x":"所以每个工具都有优点和缺点，每个工具都有它适用的情况。\n我们在本书中将会介绍它们两个的基本用法。","l":"\n"},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"你需要有一个基于 TFVC 的仓库来执行后续的指令。\n现实中它们并没有 Git 或 Subversion 仓库那样多，所以你可能需要创建一个你自己的仓库。\nCodeplex (","l":"\n","c":[{"n":"a","x":"https://archive.codeplex.com/","l":") 或 Visual Studio Online (","a":[["href","https://archive.codeplex.com/"],["class","link"]]},{"n":"a","x":"http://www.visualstudio.com","l":") 都是非常好的选择。","a":[["href","http://www.visualstudio.com"],["class","link"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","使用：git-tf"]],"c":[{"n":"h4","x":"使用：","l":"\n","a":[["id","_使用_code_class_literal_git_tf_code"]],"c":[{"n":"code","x":"git-tf","a":[["class","literal"]]}]},{"n":"p","x":"和其它任何 Git 项目一样，你要做的第一件事是克隆。\n使用 ","l":"\n","c":[{"n":"code","x":"git-tf","l":" 克隆看起来像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"第一个参数是一个 TFVC 集的 URL，第二个参数类似于 ","l":"\n","c":[{"n":"code","x":"$/project/branch","l":" 的形式，第三个参数是将要创建的本地 Git 仓库路径（最后一项可以省略）。\nGit-tf 同一时间只能工作在一个分支上；如果你想要检入一个不同的 TFVC 分支，你需要从那个分支克隆一份新的。","a":[["class","literal"]]}]},{"n":"p","x":"这会创建一个完整功能的 Git 仓库：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"cd project_git\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --all --oneline --decorate\n512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这叫做 ","l":"\n","c":[{"n":"em","x":"浅","l":" 克隆，意味着只下载了最新的变更集。\nTFVC 并未设计成为每一个客户端提供一份全部历史记录的拷贝，所以 git-tf 默认行为是获得最新的版本，这样更快一些。"}]},{"n":"p","x":"如果愿意多花一些时间，使用 ","l":"\n","c":[{"n":"code","x":"--deep","l":" 选项克隆整个项目历史可能更有价值。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\\","l":"\n  project_git --deep\nUsername: domain\\user\nPassword:\nConnecting to TFS...\nCloning $/myproject into /tmp/project_git: 100%, done.\nCloned 4 changesets. Cloned last changeset 35190 as d44b17a\n","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"$ ","l":"cd project_git\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --all --oneline --decorate\nd44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye\n126aa7b (tag: TFS_C35189)\n8f77431 (tag: TFS_C35178) FIRST\n0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \\\n        Team Project Creation Wizard","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意名字类似 ","l":"\n","c":[{"n":"code","x":"TFS_C35189","l":" 的标签；这是一个帮助你知道 Git 提交与 TFVC 变更集关联的功能。\n这是一种优雅的表示方式，因为通过一个简单的 log 命令就可以看到你的提交是如何与 TFVC 中已存在快照关联起来的。\n它们并不是必须的（并且实际上可以使用 ","a":[["class","literal"]]},{"n":"code","x":"git config git-tf.tag false","l":" 来关闭它们）- git-tf 会在 ","a":[["class","literal"]]},{"n":"code","x":".git/git-tf","l":" 文件中保存真正的提交与变更集的映射。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","使用：git-tfs"]],"c":[{"n":"h4","x":"使用：","l":"\n","a":[["id","_使用_code_class_literal_git_tfs_code"]],"c":[{"n":"code","x":"git-tfs","a":[["class","literal"]]}]},{"n":"p","x":"Git-tfs 克隆行为略为不同。\n观察：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git tfs clone --with-branches \\\n    https"},{"n":"span","x":":","l":"//username.visualstudio.com/DefaultCollection \\\n    $/project/Trunk project_git\nInitialized empty Git repository ","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":"in","l":" C","a":[["style","font-weight: bold"]]},{"n":"span","x":":","l":"/Users/ben/project_git/.git/\nC15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9\nC16 = c403405f4989d73a2c3c119e79021cb2104ce44a\nTfs branches found","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":"\n- $/tfvc-test/featureA\nThe name of the local branch will be ","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":" featureA\nC17 = d202b53f67bde32171d5078968c644e562f1c439\nC18 = 44cd729d8df868a8be20438fdeeefb961958b674","a":[["style","border: 1px solid #FF0000"]]}]}]}]},{"n":"p","x":"注意 ","l":"\n","c":[{"n":"code","x":"--with-branches","l":" 选项。\nGit-tfs 能够映射 TFVC 分支到 Git 分支，这个标记告诉它为每一个 TFVC 分支建立一个本地的 Git 分支。\n强烈推荐曾经在 TFS 中新建过分支或合并过分支的仓库使用这个标记，但是如果使用的服务器的版本比 TFS 2010 更老——在那个版本前，“分支”只是文件夹，所以 git-tfs 无法将它们与普通文件夹区分开。","a":[["class","literal"]]}]},{"n":"p","x":"让我们看一下最终的 Git 仓库：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git log --oneline --graph --decorate --all\n* 44cd729 (tfs/featureA, featureA) Goodbye\n* d202b53 Branched from $/tfvc-test/Trunk\n* c403405 (HEAD, tfs/"},{"n":"span","x":"default","l":", master) Hello\n* b75da1a New project\nPS> git log -1\ncommit c403405f4989d73a2c3c119e79021cb2104ce44a\nAuthor","a":[["style","font-weight: bold"]]},{"n":"span","x":":","l":" Ben Straub <ben@straub.cc>\nDate","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":"   Fri Aug 1 03","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":"41","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":"59 2014 +0000\n\n    Hello\n\n    git-tfs-id","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":" [https","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":"//username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16","a":[["style","border: 1px solid #FF0000"]]}]}]}]},{"n":"p","x":"有两个本地分支，","l":"\n","c":[{"n":"code","x":"master","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"featureA","l":"，分别代表着克隆（TFVC 中的 ","a":[["class","literal"]]},{"n":"code","x":"Trunk","l":"）与子分支（TFVC 中的 ","a":[["class","literal"]]},{"n":"code","x":"featureA","l":"）的初始状态。\n也可以看到 ","a":[["class","literal"]]},{"n":"code","x":"tfs","l":" “remote” 也有一对引用：","a":[["class","literal"]]},{"n":"code","x":"default","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"featureA","l":"，代表 TFVC 分支。\nGit-tfs 映射从 ","a":[["class","literal"]]},{"n":"code","x":"tfs/default","l":" 克隆的分支，其他的会有它们自己的名字。","a":[["class","literal"]]}]},{"n":"p","x":"另一件需要注意的事情是在提交信息中的 ","l":"\n","c":[{"n":"code","x":"git-tfs-id:","l":" 行。\nGit-tfs 使用这些标记而不是标签来关联 TFVC 变更集与 Git 提交。\n有一个潜在的问题是 Git 提交在推送到 TFVC 前后会有不同的 SHA-1 校验和。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git-tf[s] 工作流程"]],"c":[{"n":"h4","x":"Git-tf[s] 工作流程","l":"\n","a":[["id","_git_tf_s_工作流程"]]},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"无论你使用哪个工具，都需要先设置几个 Git 配置选项来避免一些问题。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git config set --local core.ignorecase=true\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git config set --local core.autocrlf=false","a":[["style","font-weight: bold"]]}]}]}]}]}]},{"n":"p","x":"显然，接下来要做的事情就是要在项目中做一些工作。\nTFVC 与 TFS 有几个功能可能会增加你的工作流程的复杂性：","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","ordered-list arabic"]],"c":[{"n":"ol","x":"\n","l":"\n","a":[["class","arabic"]],"c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"TFVC 无法表示主题分支，这会增加一点复杂度。\n这会导致需要以 ","l":"\n","a":[["class","principal"]],"c":[{"n":"strong","x":"非常","l":" 不同的方式使用 TFVC 与 Git 表示的分支。"}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"要意识到 TFVC 允许用户从服务器上“检出”文件并锁定它们，这样其他人就无法编辑了。\n显然它不会阻止你在本地仓库中编辑它们，但是当推送你的修改到 TFVC 服务器时会出现问题。","l":"\n","a":[["class","principal"]]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"TFS 有一个“封闭”检入的概念，TFS 构建-测试循环必须在检入被允许前成功完成。\n这使用了 TFVC 的“shelve”功能，我们不会在这里详述。\n  可以通过 git-tf 手动地模拟这个功能，并且 git-tfs 提供了封闭敏感的 ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":"checkintool","l":" 命令。","a":[["class","literal"]]}]}]}]}]},{"n":"p","x":"出于简洁性的原因，我们这里介绍的是一种轻松的方式，回避并避免了大部分问题。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","工作流程：git-tf"]],"c":[{"n":"h4","x":"工作流程：","l":"\n","a":[["id","_工作流程_code_class_literal_git_tf_code"]],"c":[{"n":"code","x":"git-tf","a":[["class","literal"]]}]},{"n":"p","x":"假定你完成了一些工作，在 ","l":"\n","c":[{"n":"code","x":"master","l":" 中做了几次 Git 提交，然后准备将你的进度共享到服务器。\n这是我们的 Git 仓库：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate --all\n* 4178a82 (HEAD, master) update code\n* 9df2ae3 update readme\n* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye\n* 126aa7b (tag: TFS_C35189)\n* 8f77431 (tag: TFS_C35178) FIRST\n* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \\\n          Team Project Creation Wizard","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"我们想要拿到在 ","l":"\n","c":[{"n":"code","x":"4178a82","l":" 提交的快照并将其推送到 TFVC 服务器。\n先说重要的：让我们看看自从上次连接后我们的队友是否进行过改动：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git tf fetch\nUsername: domain\\user\nPassword:\nConnecting to TFS...\nFetching $/myproject at latest changeset: 100%, done.\nDownloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate --all\n* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text\n| * 4178a82 (HEAD, master) update code\n| * 9df2ae3 update readme\n|/\n* d44b17a (tag: TFS_C35190) Goodbye\n* 126aa7b (tag: TFS_C35189)\n* 8f77431 (tag: TFS_C35178) FIRST\n* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \\\n          Team Project Creation Wizard","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"看起来其他人也做了一些改动，现在我们有一个分叉的历史。\n这就是 Git 的优势，但是我们现在有两种处理的方式：","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","ordered-list arabic"]],"c":[{"n":"ol","x":"\n","l":"\n","a":[["class","arabic"]],"c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"像一名 Git 用户一样自然的生成一个合并提交（毕竟，那也是 ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":"git pull","l":" 做的），git-tf 可以通过一个简单的 ","a":[["class","literal"]]},{"n":"code","x":"git tf pull","l":" 来帮你完成。\n然而，我们要注意的是，TFVC 却并不这样想，如果你推送合并提交那么你的历史在两边看起来都不一样，这会造成困惑。\n其次，如果你计划将所有你的改动提交为一次变更集，这可能是最简单的选择。","a":[["class","literal"]]}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"变基使我们的提交历史变成直线，这意味着我们有个选项可以将我们的每一个 Git 提交转换为一个 TFVC 变更集。\n因为这种方式为其他选项留下了可能，所以我们推荐你这样做；git-tf 可以很简单地通过 ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":"git tf pull --rebase","l":" 帮你达成目标。","a":[["class","literal"]]}]}]}]}]},{"n":"p","x":"这是你的选择。\n在本例中，我们会进行变基：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git rebase FETCH_HEAD\nFirst, rewinding head to replay your work on top of it...\nApplying: update readme\nApplying: update code\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate --all\n* 5a0e25e (HEAD, master) update code\n* 6eb3eb5 update readme\n* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text\n* d44b17a (tag: TFS_C35190) Goodbye\n* 126aa7b (tag: TFS_C35189)\n* 8f77431 (tag: TFS_C35178) FIRST\n* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \\\n          Team Project Creation Wizard","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在我们准备好生成一个检入来推送到 TFVC 服务器上了。\nGit-tf 给你一个将自上次修改（即 ","l":"\n","c":[{"n":"code","x":"--shallow","l":" 选项，默认启用）以来所有的修改生成的一个单独的变更集以及为每一个 Git 提交（","a":[["class","literal"]]},{"n":"code","x":"--deep","l":"）生成的一个新的变更集。\n在本例中，我们将会创建一个变更集：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git tf checkin -m ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'Updating readme and code'","l":"\nUsername: domain\\user\nPassword:\nConnecting to TFS...\nChecking in to $/myproject: 100%, done.\nChecked commit 5a0e25e in as changeset 35348\n","a":[["style","font-style: italic"]]},{"n":"span","x":"$ ","l":"git log --oneline --graph --decorate --all\n* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code\n* 6eb3eb5 update readme\n* 8ef06a8 (tag: TFS_C35320) just some text\n* d44b17a (tag: TFS_C35190) Goodbye\n* 126aa7b (tag: TFS_C35189)\n* 8f77431 (tag: TFS_C35178) FIRST\n* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \\\n          Team Project Creation Wizard","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"那有一个新标签 ","l":"\n","c":[{"n":"code","x":"TFS_C35348","l":"，表明 TFVC 已经存储了一个相当于 ","a":[["class","literal"]]},{"n":"code","x":"5a0e25e","l":" 提交的快照。\n要重点注意的是，不是每一个 Git 提交都需要在 TFVC 中存在一个相同的副本；例如 ","a":[["class","literal"]]},{"n":"code","x":"6eb3eb5","l":" 提交，在服务器上并不存在。","a":[["class","literal"]]}]},{"n":"p","x":"这就是主要的工作流程。\n有一些你需要考虑的其他注意事项：","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","itemized-list"]],"c":[{"n":"ul","x":"\n","l":"\n","c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"没有分支。\nGit-tf 同一时间只能从一个 TFVC 分支创建一个 Git 仓库。","l":"\n","a":[["class","principal"]]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"协作时使用 TFVC 或 Git，而不是两者同时使用。\n同一个 TFVC 仓库的不同 git-tf 克隆会有不同的 SHA-1 校验和，这会导致无尽的头痛问题。","l":"\n","a":[["class","principal"]]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"如果你的团队的工作流程包括在 Git 中协作并定期与 TFVC 同步，只能使用其中的一个 Git 仓库连接到 TFVC。","l":"\n","a":[["class","principal"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","工作流程：git-tfs"]],"c":[{"n":"h4","x":"工作流程：","l":"\n","a":[["id","_工作流程_code_class_literal_git_tfs_code"]],"c":[{"n":"code","x":"git-tfs","a":[["class","literal"]]}]},{"n":"p","x":"让我们使用 git-tfs 来走一遍同样的情景。\n这是我们在 Git 仓库中 ","l":"\n","c":[{"n":"code","x":"master","l":" 分支上生成的几个新提交：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git log --oneline --graph --all --decorate\n* c3bd3ae (HEAD, master) update code\n* d85e5a2 update readme\n| * 44cd729 (tfs/featureA, featureA) Goodbye\n| * d202b53 Branched from $/tfvc-test/Trunk\n|/\n* c403405 (tfs/"},{"n":"span","x":"default","l":") Hello\n* b75da1a New project","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"让我们看一下在我们工作时有没有人完成一些其它的工作：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git tfs fetch\nC19 = aea74a0313de0a391940c999e51c5c15c381d91d\nPS> git log --all --oneline --graph --decorate\n* aea74a0 (tfs/"},{"n":"span","x":"default","l":") update documentation\n| * c3bd3ae (HEAD, master) update code\n| * d85e5a2 update readme\n|/\n| * 44cd729 (tfs/featureA, featureA) Goodbye\n| * d202b53 Branched from $/tfvc-test/Trunk\n|/\n* c403405 Hello\n* b75da1a New project","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"是的，那说明我们的同事增加了一个新的 TFVC 变更集，显示为新的 ","l":"\n","c":[{"n":"code","x":"aea74a0","l":" 提交，而 ","a":[["class","literal"]]},{"n":"code","x":"tfs/default","l":" 远程分支已经被移除了。","a":[["class","literal"]]}]},{"n":"p","x":"与 git-tf 相同，我们有两种基础选项来解决这个分叉历史问题：","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","ordered-list arabic"]],"c":[{"n":"ol","x":"\n","l":"\n","a":[["class","arabic"]],"c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"通过变基来保持历史是线性的。","l":"\n","a":[["class","principal"]]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"通过合并来保留改动。","l":"\n","a":[["class","principal"]]}]}]}]},{"n":"p","x":"在本例中，我们将要做一个“深”检入，也就是说每一个 Git 提交会变成一个 TFVC 变更集，所以我们想要变基。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git rebase tfs/"},{"n":"span","x":"default","l":"\nFirst, rewinding head to replay your work on top of it...\nApplying","a":[["style","font-weight: bold"]]},{"n":"span","x":":","l":" update readme\nApplying","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":":","l":" update code\nPS> git log --all --oneline --graph --decorate\n* 10a75ac (HEAD, master) update code\n* 5cec4ab update readme\n* aea74a0 (tfs/","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":"default","l":") update documentation\n| * 44cd729 (tfs/featureA, featureA) Goodbye\n| * d202b53 Branched from $/tfvc-test/Trunk\n|/\n* c403405 Hello\n* b75da1a New project","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在已经准备好通过检入我们的代码到 TFVC 服务器来完成贡献。\n我们这里将会使用 ","l":"\n","c":[{"n":"code","x":"rcheckin","l":" 命令将 HEAD 到第一个 ","a":[["class","literal"]]},{"n":"code","x":"tfs","l":" 远程分支间的每一个 Git 提交转换为一个 TFVC 变更集（","a":[["class","literal"]]},{"n":"code","x":"checkin","l":" 命令只会创建一个变更集，有些类似于压缩 Git 提交）。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git tfs rcheckin\nWorking with tfs remote"},{"n":"span","x":":","l":" ","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":"default","l":"\nFetching changes from TFS to minimize possibility of late conflict...\nStarting checkin of 5cec4ab4 ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'update readme'","l":"\n add README.md\nC20 = 71a5ddce274c19f8fdc322b4f165d93d89121017\nDone with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...\nRebase done successfully.\nStarting checkin of b1bf0f99 ","a":[["style","font-style: italic"]]},{"n":"span","x":"'update code'","l":"\n edit .git\\tfs\\","a":[["style","font-style: italic"]]},{"n":"span","x":"default","l":"\\workspace\\ConsoleApplication1/ConsoleApplication1/Program.cs\nC21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b\nDone with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...\nRebase done successfully.\nNo more to rcheckin.\nPS> git log --all --oneline --graph --decorate\n* ff04e7c (HEAD, tfs/","a":[["style","font-weight: bold"]]},{"n":"span","x":"default","l":", master) update code\n* 71a5ddc update readme\n* aea74a0 update documentation\n| * 44cd729 (tfs/featureA, featureA) Goodbye\n| * d202b53 Branched from $/tfvc-test/Trunk\n|/\n* c403405 Hello\n* b75da1a New project","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意在每次成功检入到 TFVC 服务器后，git-tfs 是如何将剩余的工作变基到服务器上。\n这是因为它将 ","l":"\n","c":[{"n":"code","x":"git-tfs-id","l":" 属性加入到提交信息的底部，这将会改变 SHA-1 校验和。\n这恰恰是有意设计的，没有什么事情可以担心了，但是你应该意识到发生了什么，特别是当你想要与其他人共享 Git 提交时。","a":[["class","literal"]]}]},{"n":"p","x":"TFS 有许多与它的版本管理系统整合的功能，比如工作项目、指定审核者、封闭检入等等。\n仅仅通过命令行工具使用这些功能来工作是很笨重的，但是幸运的是 git-tfs 允许你轻松地运行一个图形化的检入工具：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git tfs checkintool\nPS> git tfs ct"}]}]}]},{"n":"p","x":"它看起来有点像这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","image"]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"img","l":"\n","a":[["src","images/git-tfs-ct.png"],["alt","git-tfs 检入工具。"],["data-calibre-src","OEBPS/images/git-tfs-ct.png"]]}]},{"n":"figcaption","x":"Figure 3. git-tfs 检入工具。","l":"\n"}]},{"n":"p","x":"对 TFS 用户来说这看起来很熟悉，因为它就是从 Visual Studio 中运行的同一个窗口。","l":"\n"},{"n":"p","x":"Git-tfs 同样允许你从你的 Git 仓库控制 TFVC 分支。\n如同这个例子，让我们创建一个：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git tfs branch $/tfvc-test/featureBee\nThe name of the local branch will be "},{"n":"span","x":":","l":" featureBee\nC26 = 1d54865c397608c004a2cadce7296f5edc22a7e5\nPS> git log --oneline --graph --decorate --all\n* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee\n* ff04e7c (HEAD, tfs/","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":"default","l":", master) update code\n* 71a5ddc update readme\n* aea74a0 update documentation\n| * 44cd729 (tfs/featureA, featureA) Goodbye\n| * d202b53 Branched from $/tfvc-test/Trunk\n|/\n* c403405 Hello\n* b75da1a New project","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"在 TFVC 中创建一个分支意味着增加一个使分支存在的变更集，这会映射为一个 Git 提交。\n也要注意的是 git-tfs ","l":"\n","c":[{"n":"strong","x":"创建","l":" 了 "},{"n":"code","x":"tfs/featureBee","l":" 远程分支，但是 ","a":[["class","literal"]]},{"n":"code","x":"HEAD","l":" 始终指向 ","a":[["class","literal"]]},{"n":"code","x":"master","l":"。\n如果你想要在新生成的分支上工作，那你也许应该通过从那次提交创建一个主题分支的方式使你新的提交基于 ","a":[["class","literal"]]},{"n":"code","x":"1d54865","l":" 提交。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git 与 TFS 总结"]],"c":[{"n":"h4","x":"Git 与 TFS 总结","l":"\n","a":[["id","_git_与_tfs_总结"]]},{"n":"p","x":"Git-tf 与 Git-tfs 都是与 TFVC 服务器交互的很好的工具。\n它们允许你在本地使用 Git 的能力，避免与中央 TFVC 服务器频繁交流，\n使你做为一个开发者的生活更轻松，而不用强制整个团队迁移到 Git。\n如果你在 Windows 上工作（那很有可能你的团队正在使用 TFS），你可能会想要使用 git-tfs，\n因为它的功能更完整，但是如果你在其他平台工作，你只能使用略有限制的 git-tf。\n像本章中大多数工具一样，你应当使用其中的一个版本系统作为主要的，\n而使用另一个做为次要的——不管是 Git 还是 TFVC 都可以做为协作中心，但不是两者都用。","l":"\n"}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","迁移到 Git"]],"c":[{"n":"h2","x":"迁移到 Git","l":"\n","a":[["id","_migrating"]]},{"n":"p","x":"\n如果你现在有一个正在使用其他 VCS 的代码库，但是你已经决定开始使用 Git，必须通过某种方式将你的项目迁移至 Git。\n这一部分会介绍一些通用系统的导入器，然后演示如何开发你自己定制的导入器。\n你将会学习如何从几个大型专业应用的 SCM 系统中导入数据，不仅因为它们是大多数想要转换的用户正在使用的系统，也因为获取针对它们的高质量工具很容易。","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Subversion"]],"c":[{"n":"h3","x":"Subversion","l":"\n","a":[["id","_subversion"]]},{"n":"p","x":"\n\n如果你阅读过前面关于 ","l":"\n","c":[{"n":"code","x":"git svn","l":" 的章节，可以轻松地使用那些指令来 ","a":[["class","literal"]]},{"n":"code","x":"git svn clone","l":" 一个仓库，停止使用 Subversion 服务器，推送到一个新的 Git 服务器，然后就可以开始使用了。\n如果你想要历史，可以从 Subversion 服务器上尽可能快地拉取数据来完成这件事（这可能会花费一些时间）。","a":[["class","literal"]]}]},{"n":"p","x":"然而，导入并不完美；因为花费太长时间了，你可能早已用其他方法完成导入操作。\n导入产生的第一个问题就是作者信息。\n在 Subversion 中，每一个人提交时都需要在系统中有一个用户，它会被记录在提交信息内。\n在之前章节的例子中几个地方显示了 ","l":"\n","c":[{"n":"code","x":"schacon","l":"，比如 ","a":[["class","literal"]]},{"n":"code","x":"blame","l":" 输出与 ","a":[["class","literal"]]},{"n":"code","x":"git svn log","l":"。\n如果想要将上面的 Subversion 用户映射到一个更好的 Git 作者数据中，你需要一个 Subversion 用户到 Git 用户的映射。\n创建一个 ","a":[["class","literal"]]},{"n":"code","x":"users.txt","l":" 的文件包含像下面这种格式的映射：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"schacon = Scott Chacon <schacon@geemail.com>\nselse = Someo Nelse <selse@geemail.com>"}]}]},{"n":"p","x":"为了获得 SVN 使用的作者名字列表，可以运行这个：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"svn log --xml --quiet | grep author | sort -u | ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\\","l":"\n  perl -pe 's/.*>(.*?)<.*/$1 = /'","a":[["style","font-weight: bold; font-style: italic"]]}]}]}]},{"n":"p","x":"这会将日志输出为 XML 格式，然后保留作者信息行、去除重复、去除 XML 标记。\n很显然这只会在安装了 ","l":"\n","c":[{"n":"code","x":"grep","l":"、","a":[["class","literal"]]},{"n":"code","x":"sort","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"perl","l":" 的机器上运行。\n然后，将输出重定向到你的 ","a":[["class","literal"]]},{"n":"code","x":"users.txt","l":" 文件中，这样就可以在每一个记录后面加入对应的 Git 用户数据。","a":[["class","literal"]]}]},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"如果你在 Windows 上运行它，那么到这里就会遇到问题。微软提供了一些不错的建议和示例：\n","l":"\n","c":[{"n":"a","x":"https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git","l":".","a":[["href","https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git"],["class","link"]]}]}]}]},{"n":"p","x":"你可以将此文件提供给 ","l":"\n","c":[{"n":"code","x":"git svn","l":" 来帮助它更加精确地映射作者数据。\n也可以通过传递 ","a":[["class","literal"]]},{"n":"code","x":"--no-metadata","l":" 给 ","a":[["class","literal"]]},{"n":"code","x":"clone","l":" 与 ","a":[["class","literal"]]},{"n":"code","x":"init","l":" 命令，告诉 ","a":[["class","literal"]]},{"n":"code","x":"git svn","l":" 不要包括\nSubversion 通常会导入的元数据。在导入过程中，Git 会在每个提交说明的元数据中生成一个\n","a":[["class","literal"]]},{"n":"code","x":"git-svn-id","l":"。","a":[["class","literal"]]}]},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"当你想要将 Git 仓库中的提交镜像回原 SVN 仓库中时，需要保留元数据。\n如果你不想在提交记录中同步它，请直接省略掉 ","l":"\n","c":[{"n":"code","x":"--no-metadata","l":" 选项。","a":[["class","literal"]]}]}]}]},{"n":"p","x":"这会使你的 ","l":"\n","c":[{"n":"code","x":"import","l":" 命令看起来像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git svn clone http://my-project.googlecode.com/svn/ ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\\","l":"\n      --authors-file=users.txt --no-metadata --prefix \"\" -s my_project\n","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"$ ","l":"cd my_project","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在在 ","l":"\n","c":[{"n":"code","x":"my_project","l":" 目录中应当有了一个更好的 Subversion 导入。\n并不像是下面这样的提交：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"commit 37efa680e8473b615de980fa935944215428a35a\nAuthor: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>\nDate:   Sun May 3 00:12:22 2009 +0000\n\n    fixed install - go to trunk\n\n    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-\n    be05-5f7a86268029"}]}]},{"n":"p","x":"反而它们看起来像是这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2\nAuthor: Scott Chacon <schacon@geemail.com>\nDate:   Sun May 3 00:12:22 2009 +0000\n\n    fixed install - go to trunk"}]}]},{"n":"p","x":"不仅是 Author 字段更好看了，","l":"\n","c":[{"n":"code","x":"git-svn-id","l":" 也不在了。","a":[["class","literal"]]}]},{"n":"p","x":"之后，你应当做一些导入后的清理工作。\n第一步，你应当清理 ","l":"\n","c":[{"n":"code","x":"git svn","l":" 设置的奇怪的引用。\n首先移动标签，这样它们就是标签而不是奇怪的远程引用，然后你会移动剩余的分支这样它们就是本地的了。","a":[["class","literal"]]}]},{"n":"p","x":"为了将标签变为合适的 Git 标签，运行：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ for","l":" t ","a":[["style","font-weight: bold"]]},{"n":"span","x":"in","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"$(","l":"git ","a":[["style","font-weight: bold"]]},{"n":"span","x":"for","l":"-each-ref --format=","a":[["style","font-weight: bold"]]},{"n":"span","x":"'%(refname:short)'","l":" refs/remotes/tags","a":[["style","font-style: italic"]]},{"n":"span","x":")","l":"; ","a":[["style","font-weight: bold"]]},{"n":"span","x":"do","l":" git tag ","a":[["style","font-weight: bold"]]},{"n":"span","x":"${","l":"t/tags","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\\/","l":"/","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","l":" $t && git branch -D -r $t; ","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"done","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这会使原来在 ","l":"\n","c":[{"n":"code","x":"refs/remotes/tags/","l":" 里的远程分支引用变成真正的（轻量）标签。","a":[["class","literal"]]}]},{"n":"p","x":"接下来，将 ","l":"\n","c":[{"n":"code","x":"refs/remotes","l":" 下剩余的引用移动为本地分支：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ for","l":" b ","a":[["style","font-weight: bold"]]},{"n":"span","x":"in","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"$(","l":"git ","a":[["style","font-weight: bold"]]},{"n":"span","x":"for","l":"-each-ref --format=","a":[["style","font-weight: bold"]]},{"n":"span","x":"'%(refname:short)'","l":" refs/remotes","a":[["style","font-style: italic"]]},{"n":"span","x":")","l":"; ","a":[["style","font-weight: bold"]]},{"n":"span","x":"do","l":" git branch $b refs/remotes/$b && git branch -D -r $b; ","a":[["style","font-weight: bold"]]},{"n":"span","x":"done","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"你可能会看到一些额外的分支，这些分支的后缀是 ","l":"\n","c":[{"n":"code","x":"@xxx","l":" (其中 xxx 是一个数字)，而在 Subversion 中你只会看到一个分支。这实际上是 Subversion 一个叫做“peg-revisions”的功能，Git在语法上没有与之对应的功能。因此， ","a":[["class","literal"]]},{"n":"code","x":"git svn","l":" 只是简单地将 SVN peg-revision 版本号添加到分支名称中，这同你在 SVN 中修改分支名称来定位一个分支的“peg-revision”是一样的。如果你对于 peg-revisions 完全不在乎，通过下面的命令可以轻易地移除他们：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ for","l":" p ","a":[["style","font-weight: bold"]]},{"n":"span","x":"in","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"$(","l":"git ","a":[["style","font-weight: bold"]]},{"n":"span","x":"for","l":"-each-ref --format=","a":[["style","font-weight: bold"]]},{"n":"span","x":"'%(refname:short)'","l":" | grep @","a":[["style","font-style: italic"]]},{"n":"span","x":")","l":"; ","a":[["style","font-weight: bold"]]},{"n":"span","x":"do","l":" git branch -D $p; ","a":[["style","font-weight: bold"]]},{"n":"span","x":"done","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在所有的旧分支都是真正的 Git 分支，并且所有的旧标签都是真正的 Git 标签。","l":"\n"},{"n":"p","x":"还有最后一点东西需要清理。","l":"\n","c":[{"n":"code","x":"git svn","l":" 会创建一个名为 ","a":[["class","literal"]]},{"n":"code","x":"trunk","l":" 的额外分支，它对应于\nSubversion 的默认分支，然而 ","a":[["class","literal"]]},{"n":"code","x":"trunk","l":" 引用和 ","a":[["class","literal"]]},{"n":"code","x":"master","l":" 指向同一个位置。\n鉴于在 Git 中 ","a":[["class","literal"]]},{"n":"code","x":"master","l":" 最为常用，因此我们可以移除额外的分支：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git branch -d trunk","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"最后一件要做的事情是，将你的新 Git 服务器添加为远程仓库并推送到上面。\n下面是一个将你的服务器添加为远程仓库的例子：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git remote add origin git@my-git-server:myrepository.git","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"因为想要上传所有分支与标签，你现在可以运行：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git push origin --all\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git push origin --tags","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"通过以上漂亮、干净地导入操作，你的所有分支与标签都应该在新 Git 服务器上。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Mercurial"]],"c":[{"n":"h3","x":"Mercurial","l":"\n","a":[["id","_mercurial"]]},{"n":"p","x":"\n因为 Mercurial 与 Git 在表示版本时有着非常相似的模型，也因为 Git 拥有更加强大的灵活性，将一个仓库从 Mercurial 转换到 Git 是相当直接的，使用一个叫作“hg-fast-export”的工具，需要从这里拷贝一份：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git clone https://github.com/frej/fast-export.git","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"转换的第一步就是要先得到想要转换的 Mercurial 仓库的完整克隆：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"hg clone <remote repo URL> /tmp/hg-repo","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"下一步就是创建一个作者映射文件。\nMercurial 对放入到变更集作者字段的内容比 Git 更宽容一些，所以这是一个清理的好机会。\n只需要用到 ","l":"\n","c":[{"n":"code","x":"bash","l":" 终端下的一行命令：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"cd /tmp/hg-repo\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"hg log | grep user: | sort | uniq | sed ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'s/user: *//'","l":" > ../authors","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"这会花费几秒钟，具体要看项目提交历史有多少，最终 ","l":"\n","c":[{"n":"code","x":"/tmp/authors","l":" 文件看起来会像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"bob\nbob@localhost\nbob <bob@company.com>\nbob jones <bob <AT> company <DOT> com>\nBob Jones <bob@company.com>\nJoe Smith <joe@company.com>"}]}]},{"n":"p","x":"在这个例子中，同一个人（Bob）使用不同的名字创建变更集，其中一个实际上是正确的，\n另一个完全不符合 Git 提交的规范。hg-fast-export 通过对每一行应用规则\n","l":"\n","c":[{"n":"code","x":"\"<input>\"=\"<output>\"","l":" ，将 ","a":[["class","literal"]]},{"n":"code","x":"<input>","l":" 映射到 ","a":[["class","literal"]]},{"n":"code","x":"<output>","l":" 来修正这个问题。\n在 ","a":[["class","literal"]]},{"n":"code","x":"<input>","l":" 和 ","a":[["class","literal"]]},{"n":"code","x":"<output>","l":" 字符串中，所有 Python 的 ","a":[["class","literal"]]},{"n":"code","x":"string_escape","l":"\n支持的转义序列都会被解释。如果作者映射文件中并不包含匹配的 ","a":[["class","literal"]]},{"n":"code","x":"<input>","l":"，\n那么该作者将原封不动地被发送到 Git。\n如果所有的用户名看起来都是正确的，那我们根本就不需要这个文件。\n在本例中，我们会使文件看起来像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"\"bob\"=\"Bob Jones <bob@company.com>\"\n\"bob@localhost\"=\"Bob Jones <bob@company.com>\"\n\"bob <bob@company.com>\"=\"Bob Jones <bob@company.com>\"\n\"bob jones <bob <AT> company <DOT> com>\"=\"Bob Jones <bob@company.com>\""}]}]},{"n":"p","x":"当分支和标签 Mercurial 中的名字在 Git 中不允许时，这种映射文件也可以用来重命名它们。","l":"\n"},{"n":"p","x":"下一步是创建一个新的 Git 仓库，然后运行导出脚本：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git init /tmp/converted\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"cd /tmp/converted\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"/tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"-r","l":" 选项告诉 hg-fast-export 去哪里寻找我们想要转换的 Mercurial 仓库，","a":[["class","literal"]]},{"n":"code","x":"-A","l":"\n标记告诉它在哪找到作者映射文件（分支和标签的映射文件分别通过 ","a":[["class","literal"]]},{"n":"code","x":"-B","l":" 和 ","a":[["class","literal"]]},{"n":"code","x":"-T","l":" 选项来指定）。\n这个脚本会分析 Mercurial 变更集然后将它们转换成 Git“fast-import”功能（我们将在之后详细讨论）需要的脚本。\n这会花一点时间（尽管它比通过网格 ","a":[["class","literal"]]},{"n":"em","x":"更","l":" 快），输出相当的冗长："}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"/tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors\nLoaded 4 authors\nmaster: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files\nmaster: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files\nmaster: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files\n[…]\nmaster: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files\nmaster: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files\nmaster: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files\nExporting tag [0.4c] at [hg r9] [git :10]\nExporting tag [0.4d] at [hg r16] [git :17]\n[…]\nExporting tag [3.1-rc] at [hg r21926] [git :21927]\nExporting tag [3.1] at [hg r21973] [git :21974]\nIssued 22315 commands\ngit-fast-import statistics:\n---------------------------------------------------------------------\nAlloc'd objects:     120000\nTotal objects:       115032 (    208171 duplicates                  )\n      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)\n      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)\n      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)\n      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)\nTotal branches:         109 (         2 loads     )\n      marks:        1048576 (     22208 unique    )\n      atoms:           1952\nMemory total:          7860 KiB\n       pools:          2235 KiB\n     objects:          5625 KiB\n---------------------------------------------------------------------\npack_report: getpagesize()            =       4096\npack_report: core.packedGitWindowSize = 1073741824\npack_report: core.packedGitLimit      = 8589934592\npack_report: pack_used_ctr            =      90430\npack_report: pack_mmap_calls          =      46771\npack_report: pack_open_windows        =          1 /          1\npack_report: pack_mapped              =  340852700 /  340852700\n---------------------------------------------------------------------\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git shortlog -sn\n   369  Bob Jones\n   365  Joe Smith","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"那看起来非常好。\n所有 Mercurial 标签都已被转换成 Git 标签，Mercurial 分支与书签都被转换成 Git 分支。\n现在已经准备好将仓库推送到新的服务器那边：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git remote add origin git@my-git-server:myrepository.git\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git push origin --all","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Bazaar"]],"c":[{"n":"h3","x":"Bazaar","l":"\n","a":[["id","_bazaar"]]},{"n":"p","l":"\n"},{"n":"p","x":"Bazaar 是一个和 Git 非常类似的分布式版本控制系统（DVCS)，因此将 Bazzar 仓库转换成 Git 仓库是非常简单易懂的。想要完成转换，你需要安装 ","l":"\n","c":[{"n":"code","x":"bzr-fastimport","l":" 插件。","a":[["class","literal"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","安装 bzr-fastimport 插件"]],"c":[{"n":"h4","x":"安装 bzr-fastimport 插件","l":"\n","a":[["id","_安装_bzr_fastimport_插件"]]},{"n":"p","x":"安装 fastimport 插件的步骤在类 UNIX 操作系统和 Windows 上是不一样的。在类 UNIX 系统上，最简单的办法就是安装 ","l":"\n","c":[{"n":"code","x":"bzr-fastimport","l":" 包，这种方法将会自动安装所有需要的依赖。","a":[["class","literal"]]}]},{"n":"p","x":"例如，使用 Debian 及其派生系统，你只需要进行以下操作：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"sudo apt-get install bzr-fastimport","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"红帽企业版系统（RHEL），使用以下命令：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"sudo yum install bzr-fastimport","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"Fedora 从 22 版本开始，采用了新的包管理器 dnf，使用以下命令：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"sudo dnf install bzr-fastimport","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"如果直接安装包的方法不行，你可能需要使用安装插件的方法：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"mkdir --parents ~/.bazaar/plugins     ","a":[["style","font-weight: bold"]]},{"n":"span","x":"# 为插件创建必要的文件夹","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"$ ","l":"cd ~/.bazaar/plugins\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"bzr branch lp:bzr-fastimport fastimport   ","a":[["style","font-weight: bold"]]},{"n":"span","x":"# 引入 fastimport 插件","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"$ ","l":"cd fastimport\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"sudo python setup.py install --record=files.txt   ","a":[["style","font-weight: bold"]]},{"n":"span","x":"# 安装插件","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"为了确保插件工作，你同时也需要安装有 ","l":"\n","c":[{"n":"code","x":"fastimport","l":" 这一 Python 模块。使用下面的命令可以检查这一模块安装与否，如果没有则安装这一模块：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"python -c ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"import fastimport\"","l":"\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nImportError: No module named fastimport\n","a":[["style","font-style: italic"]]},{"n":"span","x":"$ ","l":"pip install fastimport","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"如果上面的命令安装失败，你可以直接到这个地址下载 ","l":"\n","c":[{"n":"a","x":"https://pypi.python.org/pypi/fastimport/","l":" 。","a":[["href","https://pypi.python.org/pypi/fastimport/"],["class","link"]]}]},{"n":"p","x":"在 Windows 上，","l":"\n","c":[{"n":"code","x":"bzr-fastimport","l":" 插件在 Git 使用脱机安装并保持默认安装选项不变（可选框全部选中）的情况下是自动安装的。在这种情况下，你什么都不用做。","a":[["class","literal"]]}]},{"n":"p","x":"接下来，导入 Bazaar 仓库的方法根据你的仓库是有一个分支还是有多个分支而不同。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","单分支项目"]],"c":[{"n":"h4","x":"单分支项目","l":"\n","a":[["id","_单分支项目"]]},{"n":"p","l":"\n","c":[{"n":"code","x":"cd","l":" 到包含你的 Bazaar 仓库的路径，然后初始化 Git 仓库：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"cd /path/to/the/bzr/repository\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git init","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在你可以使用以下命令轻松地导出你的 Bazaar 仓库并把它转化成 Git 仓库：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"bzr fast-export --plain . | git fast-import","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"根据项目的大小，Git 仓库会在几秒钟到几分钟之间构建。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","多分支项目"]],"c":[{"n":"h4","x":"多分支项目","l":"\n","a":[["id","_多分支项目"]]},{"n":"p","x":"你同样也能够导入包含多个分支的 Bazaar 仓库。让我们假设你有两个分支，一个代表主分支（myProject.trunk），另一个是工作分支（myProject.work）。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"ls\nmyProject.trunk myProject.work","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"创建一个 Git 仓库并 ","l":"\n","c":[{"n":"code","x":"cd","l":" 进去：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git init git-repo\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"cd git-repo","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"将 ","l":"\n","c":[{"n":"code","x":"master","l":" 分支拉入 Git：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"bzr fast-export --export-marks=../marks.bzr ../myProject.trunk | ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\\","l":"\ngit fast-import --export-marks=../marks.git","a":[["style","font-weight: bold; font-style: italic"]]}]}]}]},{"n":"p","x":"将工作分支拉入 Git：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"bzr fast-export --marks=../marks.bzr --git-branch=work ../myProject.work | ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\\","l":"\ngit fast-import --import-marks=../marks.git --export-marks=../marks.git","a":[["style","font-weight: bold; font-style: italic"]]}]}]}]},{"n":"p","x":"现在 ","l":"\n","c":[{"n":"code","x":"git branch","l":" 会同时显示 ","a":[["class","literal"]]},{"n":"code","x":"master","l":" 分支和 ","a":[["class","literal"]]},{"n":"code","x":"work","l":" 分支。检查日志以确保它们是完整的，并删除 ","a":[["class","literal"]]},{"n":"code","x":"marks.bzr","l":" 和 ","a":[["class","literal"]]},{"n":"code","x":"marks.git","l":" 文件。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","同步暂存区"]],"c":[{"n":"h4","x":"同步暂存区","l":"\n","a":[["id","_同步暂存区"]]},{"n":"p","x":"无论你有多少分支以及使用的导入方法如何，你的暂存区都不会与 ","l":"\n","c":[{"n":"code","x":"HEAD","l":" 同步，并且在导入多个分支时，你的工作目录也不会同步。这种情况使用下面的命令可以轻松解决：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git reset --hard HEAD","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","忽略被 .bzrignore 文件指明忽略的文件"]],"c":[{"n":"h4","x":"忽略被 .bzrignore 文件指明忽略的文件","l":"\n","a":[["id","_忽略被_bzrignore_文件指明忽略的文件"]]},{"n":"p","x":"现在让我们看看要忽略的文件。第一件事情就是将 ","l":"\n","c":[{"n":"code","x":".bzrignore","l":" 重命名为 ","a":[["class","literal"]]},{"n":"code","x":".gitignore","l":"。如果 ","a":[["class","literal"]]},{"n":"code","x":".bzrignore","l":" 文件里面有一行或数行以“!!”或“RE:”开头的内容，你必须修改它，并且可能还要创建几个 ","a":[["class","literal"]]},{"n":"code","x":".gitignore","l":" 文件，以便忽略与 Bazaar 忽略的文件完全相同的文件。","a":[["class","literal"]]}]},{"n":"p","x":"最后，你必须创建一个提交，其中包含此次迁移的修改。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git mv .bzrignore .gitignore\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","a":[["style","font-weight: bold"]]},{"n":"span","x":"# modify .gitignore if needed","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"$ ","l":"git commit -am ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'Migration from Bazaar to Git'","a":[["style","font-style: italic"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","推送你的仓库到服务器"]],"c":[{"n":"h4","x":"推送你的仓库到服务器","l":"\n","a":[["id","_推送你的仓库到服务器"]]},{"n":"p","x":"终于到这一步了！\n现在你可以推送仓库到它的“云端新家”了：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git remote add origin git@my-git-server:mygitrepository.git\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git push origin --all\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git push origin --tags","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"你的 Git 仓库准备就绪。","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Perforce"]],"c":[{"n":"h3","x":"Perforce","l":"\n","a":[["id","_perforce_import"]]},{"n":"p","x":"\n下一个将要看到导入的系统是 Perforce。\n就像我们之前讨论过的，有两种方式让 Git 与 Perforce 互相通信：git-p4 与 Perforce Git Fusion。","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Perforce Git Fusion"]],"c":[{"n":"h4","x":"Perforce Git Fusion","l":"\n","a":[["id","_perforce_git_fusion"]]},{"n":"p","x":"Git Fusion 使这个过程毫无痛苦。\n只需要使用在 ","l":"\n","c":[{"n":"a","x":"Git Fusion","l":" 中讨论过的配置文件来配置你的项目设置、用户映射与分支，然后克隆整个仓库。\nGit Fusion 让你处在一个看起来像是原生 Git 仓库的环境中，如果愿意的话你可以随时将它推送到一个原生 Git 托管中。\n如果你喜欢的话甚至可以使用 Perforce 作为你的 Git 托管。","a":[["id","xref-_p4_git_fusion"],["href","javascript:void(0)"],["class","xref"],["data-Z5ljfaarsuY3mMdpckH3E3","{\"name\": \"OEBPS/ch09-git-and-other-systems.xhtml\", \"frag\": \"_p4_git_fusion\"}"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","Git-p4"]],"c":[{"n":"h4","x":"Git-p4","l":"\n","a":[["id","_git_p4"]]},{"n":"p","x":"Git-p4 也可以作为一个导入工具。\n作为例子，我们将从 Perforce 公开仓库中导入 Jam 项目。\n为了设置客户端，必须导出 P4PORT 环境变量指向 Perforce 仓库：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"export P4PORT=public.perforce.com:1666","a":[["style","font-weight: bold"]]}]}]}]},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"为了继续后续步骤，需要连接到 Perforce 仓库。\n在我们的例子中将会使用在 public.perforce.com 的公开仓库，但是你可以使用任何你有权限的仓库。","l":"\n"}]}]},{"n":"p","x":"\n运行 ","l":"\n","c":[{"n":"code","x":"git p4 clone","l":" 命令从 Perforce 服务器导入 Jam 项目，提供仓库、项目路径与你想要存放导入项目的路径：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git-p4 clone //guest/perforce_software/jam@all p4import\nImporting from //guest/perforce_software/jam@all into p4import\nInitialized empty Git repository in /private/tmp/p4import/.git/\nImport destination: refs/remotes/p4/master\nImporting revision 9957 (100%)","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"这个特定的项目只有一个分支，但是如果你在分支视图（或者说一些目录）中配置了一些分支，你可以将 ","l":"\n","c":[{"n":"code","x":"--detect-branches","l":" 选项传递给 ","a":[["class","literal"]]},{"n":"code","x":"git p4 clone","l":" 来导入项目的所有分支。\n查看 ","a":[["class","literal"]]},{"n":"a","x":"分支","l":" 来了解关于这点的更多信息。","a":[["id","xref-_git_p4_branches"],["href","javascript:void(0)"],["class","xref"],["data-Z5ljfaarsuY3mMdpckH3E3","{\"name\": \"OEBPS/ch09-git-and-other-systems.xhtml\", \"frag\": \"_git_p4_branches\"}"]]}]},{"n":"p","x":"此时你几乎已经完成了。\n如果进入 ","l":"\n","c":[{"n":"code","x":"p4import","l":" 目录中并运行 ","a":[["class","literal"]]},{"n":"code","x":"git log","l":"，可以看到你的导入工作：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log -2\ncommit e5da1c909e5db3036475419f6379f2c73710c4e6\nAuthor: giles <giles@giles@perforce.com>\nDate:   Wed Feb 8 03:13:27 2012 -0800\n\n    Correction to line 355; change </UL> to </OL>.\n\n    [git-p4: depot-paths = \"//public/jam/src/\": change = 8068]\n\ncommit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98\nAuthor: kwirth <kwirth@perforce.com>\nDate:   Tue Jul 7 01:35:51 2009 -0800\n\n    Fix spelling error on Jam doc page (cummulative -> cumulative).\n\n    [git-p4: depot-paths = \"//public/jam/src/\": change = 7304]","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"你可以看到 ","l":"\n","c":[{"n":"code","x":"git-p4","l":" 在每一个提交里都留下了一个标识符。\n如果之后想要引用 Perforce 的修改序号的话，标识符保留在那里也是可以的。\n然而，如果想要移除标识符，现在正是这么做的时候——在你开始在新仓库中工作之前。\n\n可以使用 ","a":[["class","literal"]]},{"n":"code","x":"git filter-branch","l":" 将全部标识符移除。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git filter-branch --msg-filter ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'sed -e \"/^\\[git-p4:/d\"'","l":"\nRewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)\nRef 'refs/heads/master' was rewritten","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"如果运行 ","l":"\n","c":[{"n":"code","x":"git log","l":"，你会看到所有提交的 SHA-1 校验和都改变了，但是提交信息中不再有 ","a":[["class","literal"]]},{"n":"code","x":"git-p4","l":" 字符串了：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log -2\ncommit b17341801ed838d97f7800a54a6f9b95750839b7\nAuthor: giles <giles@giles@perforce.com>\nDate:   Wed Feb 8 03:13:27 2012 -0800\n\n    Correction to line 355; change </UL> to </OL>.\n\ncommit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff\nAuthor: kwirth <kwirth@perforce.com>\nDate:   Tue Jul 7 01:35:51 2009 -0800\n\n    Fix spelling error on Jam doc page (cummulative -> cumulative).","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"现在导入已经准备好推送到你的新 Git 服务器上了。","l":"\n"}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","TFS"]],"c":[{"n":"h3","x":"TFS","l":"\n","a":[["id","_git_tfs"]]},{"n":"p","x":"\n如果你的团队正在将他们的源代码管理从 TFVC 转换为 Git，你们会想要最高程度的无损转换。\n这意味着，虽然我们在之前的交互章节介绍了 git-tfs 与 git-tf 两种工具，但是我们在本部分只能介绍 git-tfs，因为 git-tfs 支持分支，而使用 git-tf 代价太大。","l":"\n"},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"这是一个单向转换。\n这意味着 Git 仓库无法连接到原始的 TFVC 项目。","l":"\n"}]}]},{"n":"p","x":"第一件事是映射用户名。\nTFVC 对待变更集作者字段的内容相当宽容，但是 Git 需要人类可读的名字与邮箱地址。\n可以通过 ","l":"\n","c":[{"n":"code","x":"tf","l":" 命令行客户端来获取这个信息，像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> tf history $/myproject -recursive > AUTHORS_TMP"}]}]}]},{"n":"p","x":"这会将历史中的所有变更集抓取下来并放到 AUTHORS_TMP 文件中，然后我们将会将 ","l":"\n","c":[{"n":"code","x":"User","l":" 列（第二个）取出来。\n打开文件找到列开始与结束的字符并替换，在下面的命令行中，","a":[["class","literal"]]},{"n":"code","x":"cut","l":" 命令的参数 ","a":[["class","literal"]]},{"n":"code","x":"11-20","l":" 就是我们找到的：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | sort | uniq > AUTHORS"}]}]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"cut","l":" 命令只会保留每行中第 11 个到第 22 个字符。\n","a":[["class","literal"]]},{"n":"code","x":"tail","l":" 命令会跳过前两行，就是字段表头与 ASCII 风格的下划线。\n所有这些的结果通过管道送到 ","a":[["class","literal"]]},{"n":"code","x":"sort","l":" 和 ","a":[["class","literal"]]},{"n":"code","x":"uniq","l":" 来去除重复，然后保存到 ","a":[["class","literal"]]},{"n":"code","x":"AUTOHRS","l":" 文件中。\n下一步是手动的；为了让 git-tfs 有效地使用这个文件，每一行必须是这种格式：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-text"]],"c":[{"n":"code","c":[{"n":"span","l":"DOMAIN\\username = User Name <email@address.com>"}]}]}]},{"n":"p","x":"左边的部分是 TFVC 中的 “User” 字段，等号右边的部分是将被用作 Git 提交的用户名。","l":"\n"},{"n":"p","x":"一旦有了这个文件，下一件事就是生成一个你需要的 TFVC 项目的完整克隆：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git tfs clone --with-branches --authors=AUTHORS https"},{"n":"span","x":":","l":"//username.visualstudio.com/DefaultCollection $/project/Trunk project_git","a":[["style","border: 1px solid #FF0000"]]}]}]}]},{"n":"p","x":"接下来要从提交信息底部清理 ","l":"\n","c":[{"n":"code","x":"git-tfs-id","l":" 区块。\n下面的命令会完成这个任务：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-powershell"]],"c":[{"n":"code","c":[{"n":"span","l":"PS> git "},{"n":"span","x":"filter","l":"-branch -f --msg-filter ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'sed \"s/^git-tfs-id:.*$//g\"'","l":" ","a":[["style","font-style: italic"]]},{"n":"span","x":"'--'","l":" --all","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"那会使用 Git 终端环境中的 ","l":"\n","c":[{"n":"code","x":"sed","l":" 命令来将所有以 “git-tfs-id:” 开头的行替换为 Git 会忽略的空白。","a":[["class","literal"]]}]},{"n":"p","x":"全部完成后，你就已经准备好去增加一个新的远程仓库，推送你所有的分支上去，然后你的团队就可以开始用 Git 工作了。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","一个自定义的导入器"]],"c":[{"n":"h3","x":"一个自定义的导入器","l":"\n","a":[["id","_custom_importer"]]},{"n":"p","x":"\n\n如果你的系统不是上述中的任何一个，你需要在线查找一个导入器——针对许多其他系统有很多高质量的导入器，\n包括 CVS、Clear Case、Visual Source Safe，甚至是一个档案目录。\n如果没有一个工具适合你，需要一个不知名的工具，或者需要更大自由度的自定义导入过程，应当使用 ","l":"\n","c":[{"n":"code","x":"git fast-import","l":"。\n这个命令从标准输入中读取简单指令来写入特定的 Git 数据。\n通过这种方式创建 Git 对象比运行原始 Git 命令或直接写入原始对象\n（查看 ","a":[["class","literal"]]},{"n":"a","x":"Git 内部原理","l":" 了解更多内容）更容易些。\n通过这种方式你可以编写导入脚本，从你要导入的系统中读取必要数据，然后直接打印指令到标准输出。\n然后可以运行这个程序并通过 ","a":[["id","xref--ch10-git-internals"],["href","javascript:void(0)"],["class","xref"],["data-Z5ljfaarsuY3mMdpckH3E3","{\"name\": \"OEBPS/ch10-git-internals.xhtml\", \"frag\": \"\"}"]]},{"n":"code","x":"git fast-import","l":" 重定向管道输出。","a":[["class","literal"]]}]},{"n":"p","x":"为了快速演示，我们会写一个简单的导入器。\n假设你在 ","l":"\n","c":[{"n":"code","x":"current","l":" 工作，有时候会备份你的项目到时间标签 ","a":[["class","literal"]]},{"n":"code","x":"back_YYYY_MM_DD","l":" 备份目录中，你想要将这些导入到 Git 中。\n目录结构看起来是这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"ls /opt/import_from\nback_2014_01_02\nback_2014_01_04\nback_2014_01_14\nback_2014_02_03\ncurrent","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"为了导入一个 Git 目录，需要了解 Git 如何存储它的数据。\n你可能记得，Git 在底层存储指向内容快照的提交对象的链表。\n所有要做的就是告诉 ","l":"\n","c":[{"n":"code","x":"fast-import","l":" 哪些内容是快照，哪个提交数据指向它们，以及它们进入的顺序。\n你的策略是一次访问一个快照，然后用每个目录中的内容创建提交，并且将每一个提交与前一个连接起来。","a":[["class","literal"]]}]},{"n":"p","x":"如同我们在 ","l":"\n","c":[{"n":"a","x":"使用强制策略的一个例子","l":" 里做的，\n我们将会使用 Ruby 写这个，因为它是我们平常工作中使用的并且它很容易读懂。\n可以使用任何你熟悉的东西来非常轻松地写这个例子——它只需要将合适的信息打印到 ","a":[["id","xref--ch08-customizing-git--_an_example_git_enforced_policy"],["href","ch08-customizing-git.xhtml#_an_example_git_enforced_policy"],["class","xref"]]},{"n":"code","x":"标准输出","l":"。\n然而，如果你在 Windows 上，这意味着需要特别注意不要引入回车符到行尾——\n","a":[["class","literal"]]},{"n":"code","x":"git fast-import","l":" 非常特别地只接受换行符（LF）而不是 Windows 使用的回车换行符（CRLF）。","a":[["class","literal"]]}]},{"n":"p","x":"现在开始，需要进入目标目录中并识别每一个子目录，每一个都是你要导入为提交的快照。\n要进入到每个子目录中并为导出它打印必要的命令。\n基本主循环像这个样子：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"last_mark = "},{"n":"span","x":"nil","l":"\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"# loop through the directories","l":"\nDir.chdir(ARGV[0]) ","a":[["style","font-style: italic"]]},{"n":"span","x":"do","l":"\n  Dir.glob(","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"*\"","l":").each ","a":[["style","font-style: italic"]]},{"n":"span","x":"do","l":" |dir|\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"next","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" File.file?(dir)\n\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"# move into the target directory","l":"\n    Dir.chdir(dir) ","a":[["style","font-style: italic"]]},{"n":"span","x":"do","l":"\n      last_mark = print_export(dir, last_mark)\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"在每个目录内运行 ","l":"\n","c":[{"n":"code","x":"print_export","l":"，将会拿到清单并标记之前的快照，然后返回清单并标记现在的快照；通过这种方式，可以将它们合适地连接在一起。\n“标记”是一个给提交标识符的 ","a":[["class","literal"]]},{"n":"code","x":"fast-import","l":" 术语；当你创建提交，为每一个提交赋予一个标记来将它与其他提交连接在一起。\n这样，在你的 ","a":[["class","literal"]]},{"n":"code","x":"print_export","l":" 方法中第一件要做的事就是从目录名字生成一个标记：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"mark = convert_dir_to_mark(dir)"}]}]}]},{"n":"p","x":"可以创建一个目录的数组并使用索引做为标记，因为标记必须是一个整数。\n方法类似这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"$marks = []\n"},{"n":"span","x":"def","l":" convert_dir_to_mark(dir)\n  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" !$marks.include?(dir)\n    $marks << dir\n  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n  ($marks.index(dir) + 1).to_s\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"既然有一个整数代表你的提交，那还要给提交元数据一个日期。\n因为目录名字表达了日期，所以你将会从中解析出日期。\n你的 ","l":"\n","c":[{"n":"code","x":"print_export","l":" 文件的下一行是：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"date = convert_dir_to_date(dir)"}]}]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"convert_dir_to_date","l":" 定义为：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"def","l":" convert_dir_to_date(dir)\n  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" dir == ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'current'","l":"\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":"return","l":" Time.now().to_i\n  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"else","l":"\n    dir = dir.gsub(","a":[["style","font-weight: bold"]]},{"n":"span","x":"'back_'","l":", ","a":[["style","font-style: italic"]]},{"n":"span","x":"''","l":")\n    (year, month, day) = dir.split(","a":[["style","font-style: italic"]]},{"n":"span","x":"'_'","l":")\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":"return","l":" Time.local(year, month, day).to_i\n  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"那会返回每一个目录日期的整数。\n最后一项每个提交需要的元数据是提交者信息，它将会被硬编码在全局变量中：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"$author = "},{"n":"span","x":"'John Doe <john@example.com>'","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"现在准备开始为你的导入器打印出提交数据。\n初始信息声明定义了一个提交对象与它所在的分支，紧接着一个你生成的标记、提交者信息与提交信息、然后是一个之前的提交，如果它存在的话。\n代码看起来像这样：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"# print the import information","l":"\nputs ","a":[["style","font-style: italic"]]},{"n":"span","x":"'commit refs/heads/master'","l":"\nputs ","a":[["style","font-style: italic"]]},{"n":"span","x":"'mark :'","l":" + mark\nputs ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"committer ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"$author","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"date","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" -0700\"","l":"\nexport_data(","a":[["style","font-style: italic"]]},{"n":"span","x":"'imported from '","l":" + dir)\nputs ","a":[["style","font-style: italic"]]},{"n":"span","x":"'from :'","l":" + last_mark ","a":[["style","font-style: italic"]]},{"n":"span","x":"if","l":" last_mark","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"我们将硬编码时区信息（-0700），因为这样很容易。\n如果从其他系统导入，必须指定为一个偏移的时区。\n提交信息必须指定为特殊的格式：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"data (size)\\n(contents)"}]}]},{"n":"p","x":"这个格式包括文本数据、将要读取数据的大小、一个换行符、最终的数据。\n因为之后还需要为文件内容指定相同的数据格式，你需要创建一个帮助函数，","l":"\n","c":[{"n":"code","x":"export_data","l":"：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"def","l":" export_data(string)\n  print ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"data ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"string.size","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}\\n#{","l":"string","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"end","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"剩下的工作就是指定每一个快照的文件内容。\n这很轻松，因为每一个目录都是一个快照——可以在目录中的每一个文件内容后打印 ","l":"\n","c":[{"n":"code","x":"deleteall","l":" 命令。\nGit 将会适当地记录每一个快照：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"puts "},{"n":"span","x":"'deleteall'","l":"\nDir.glob(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"**/*\"","l":").each ","a":[["style","font-style: italic"]]},{"n":"span","x":"do","l":" |file|\n  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"next","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" !File.file?(file)\n  inline_data(file)\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"注意：因为大多数系统认为他们的版本是从一个提交变化到另一个提交，fast-import 也可以为每一个提交执行命令来指定哪些文件是添加的、删除的或修改的与新内容是哪些。\n可以计算快照间的不同并只提供这些数据，但是这样做会很复杂——也可以把所有数据给 Git 然后让它为你指出来。\n如果这更适合你的数据，查阅 ","l":"\n","c":[{"n":"code","x":"fast-import","l":" man 帮助页来了解如何以这种方式提供你的数据。","a":[["class","literal"]]}]},{"n":"p","x":"这种列出新文件内容或用新内容指定修改文件的格式如同下面的内容：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-"]],"c":[{"n":"code","x":"M 644 inline path/to/file\ndata (size)\n(file contents)"}]}]},{"n":"p","x":"这里，644 是模式（如果你有可执行文件，反而你需要检测并指定 755），inline 表示将会立即把内容放在本行之后。\n你的 ","l":"\n","c":[{"n":"code","x":"inline_data","l":" 方法看起来像这样：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"def","l":" inline_data(file, code = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'M'","l":", mode = ","a":[["style","font-style: italic"]]},{"n":"span","x":"'644'","l":")\n  content = File.read(file)\n  puts ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"code","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"mode","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" inline ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"file","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":"\n  export_data(content)\n","a":[["style","font-style: italic"]]},{"n":"span","x":"end","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"可以重用之前定义的 ","l":"\n","c":[{"n":"code","x":"export_data","l":" 方法，因为它与你定义的提交信息数据的方法一样。","a":[["class","literal"]]}]},{"n":"p","x":"最后一件你需要做的是返回当前的标记以便它可以传给下一个迭代：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"return","l":" mark","a":[["style","font-weight: bold"]]}]}]}]},{"n":"aside","x":"\n","l":"\n","a":[["class","admonition note"],["title","Note"],["type","note",2]],"c":[{"n":"div","x":"\n","l":"\n","a":[["class","content"]],"c":[{"n":"p","x":"如果在 Windows 上还需要确保增加一个额外步骤。\n正如之前提到的，Windows 使用 CRLF 作为换行符而 ","l":"\n","c":[{"n":"code","x":"git fast-import","l":" 只接受 LF。\n为了修正这个问题使 ","a":[["class","literal"]]},{"n":"code","x":"git fast-import","l":" 正常工作，你需要告诉 ruby 使用 LF 代替 CRLF：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"$stdout.binmode"}]}]}]}]}]},{"n":"p","x":"就是这样。\n这是全部的脚本：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"#!/usr/bin/env ruby","l":"\n\n$stdout.binmode\n$author = ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"John Doe <john@example.com>\"","l":"\n\n$marks = []\n","a":[["style","font-style: italic"]]},{"n":"span","x":"def","l":" convert_dir_to_mark(dir)\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" !$marks.include?(dir)\n        $marks << dir\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n    ($marks.index(dir)+1).to_s\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"def","l":" convert_dir_to_date(dir)\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" dir == ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'current'","l":"\n        ","a":[["style","font-style: italic"]]},{"n":"span","x":"return","l":" Time.now().to_i\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"else","l":"\n        dir = dir.gsub(","a":[["style","font-weight: bold"]]},{"n":"span","x":"'back_'","l":", ","a":[["style","font-style: italic"]]},{"n":"span","x":"''","l":")\n        (year, month, day) = dir.split(","a":[["style","font-style: italic"]]},{"n":"span","x":"'_'","l":")\n        ","a":[["style","font-style: italic"]]},{"n":"span","x":"return","l":" Time.local(year, month, day).to_i\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"def","l":" export_data(string)\n    print ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"data ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"string.size","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}\\n#{","l":"string","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"end","l":"\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"def","l":" inline_data(file, code=","a":[["style","font-weight: bold"]]},{"n":"span","x":"'M'","l":", mode=","a":[["style","font-style: italic"]]},{"n":"span","x":"'644'","l":")\n    content = File.read(file)\n    puts ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"code","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"mode","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" inline ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"file","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":"\n    export_data(content)\n","a":[["style","font-style: italic"]]},{"n":"span","x":"end","l":"\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"def","l":" print_export(dir, last_mark)\n    date = convert_dir_to_date(dir)\n    mark = convert_dir_to_mark(dir)\n\n    puts ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'commit refs/heads/master'","l":"\n    puts ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"mark :","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"mark","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":"\n    puts ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"committer ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"$author","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"date","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" -0700\"","l":"\n    export_data(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"imported from ","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"dir","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":")\n    puts ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"from :","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"last_mark","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":" ","a":[["style","font-style: italic"]]},{"n":"span","x":"if","l":" last_mark\n\n    puts ","a":[["style","font-weight: bold"]]},{"n":"span","x":"'deleteall'","l":"\n    Dir.glob(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"**/*\"","l":").each ","a":[["style","font-style: italic"]]},{"n":"span","x":"do","l":" |file|\n        ","a":[["style","font-weight: bold"]]},{"n":"span","x":"next","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" !File.file?(file)\n        inline_data(file)\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n    mark\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"# Loop through the directories","l":"\nlast_mark = ","a":[["style","font-style: italic"]]},{"n":"span","x":"nil","l":"\nDir.chdir(ARGV[0]) ","a":[["style","font-weight: bold"]]},{"n":"span","x":"do","l":"\n    Dir.glob(","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"*\"","l":").each ","a":[["style","font-style: italic"]]},{"n":"span","x":"do","l":" |dir|\n        ","a":[["style","font-weight: bold"]]},{"n":"span","x":"next","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"if","l":" File.file?(dir)\n\n        ","a":[["style","font-weight: bold"]]},{"n":"span","x":"# move into the target directory","l":"\n        Dir.chdir(dir) ","a":[["style","font-style: italic"]]},{"n":"span","x":"do","l":"\n            last_mark = print_export(dir, last_mark)\n        ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","l":"\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"end","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"如果运行这个脚本，你会得到类似下面的内容：","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"ruby import.rb /opt/import_from\ncommit refs/heads/master\nmark :1\ncommitter John Doe <john@example.com> 1388649600 -0700\ndata 29\nimported from back_2014_01_02deleteall\nM 644 inline README.md\ndata 28\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"# ","l":"Hello\n\nThis is my readme.\ncommit refs/heads/master\nmark :2\ncommitter John Doe <john@example.com> 1388822400 -0700\ndata 29\nimported from back_2014_01_04from :1\ndeleteall\nM 644 inline main.rb\ndata 34\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"#","l":"!/bin/env ruby\n\nputs \"Hey there\"\nM 644 inline README.md\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"(...)","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"为了运行导入器，将这些输出用管道重定向到你想要导入的 Git 目录中的 ","l":"\n","c":[{"n":"code","x":"git fast-import","l":"。\n可以创建一个新的目录并在其中运行 ","a":[["class","literal"]]},{"n":"code","x":"git init","l":" 作为开始，然后运行你的脚本：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git init\nInitialized empty Git repository in /opt/import_to/.git/\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"ruby import.rb /opt/import_from | git fast-import\ngit-fast-import statistics:\n---------------------------------------------------------------------\nAlloc'd objects:       5000\nTotal objects:           13 (         6 duplicates                  )\n      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)\n      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)\n      commits:            4 (         1 duplicates          0 deltas of          0 attempts)\n      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)\nTotal branches:           1 (         1 loads     )\n      marks:           1024 (         5 unique    )\n      atoms:              2\nMemory total:          2344 KiB\n       pools:          2110 KiB\n     objects:           234 KiB\n---------------------------------------------------------------------\npack_report: getpagesize()            =       4096\npack_report: core.packedGitWindowSize = 1073741824\npack_report: core.packedGitLimit      = 8589934592\npack_report: pack_used_ctr            =         10\npack_report: pack_mmap_calls          =          5\npack_report: pack_open_windows        =          2 /          2\npack_report: pack_mapped              =       1457 /       1457\n---------------------------------------------------------------------","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"正如你所看到的，当它成功完成时，它会给你一串关于它完成内容的统计。\n这本例中，一共导入了 13 个对象、4 次提交到 1 个分支。\n现在，可以运行 ","l":"\n","c":[{"n":"code","x":"git log","l":" 来看一下你的新历史：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"git log -2\ncommit 3caa046d4aac682a55867132ccdfbe0d3fdee498\nAuthor: John Doe <john@example.com>\nDate:   Tue Jul 29 19:39:04 2014 -0700\n\n    imported from current\n\ncommit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def\nAuthor: John Doe <john@example.com>\nDate:   Mon Feb 3 01:00:00 2014 -0700\n\n    imported from back_2014_02_03","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"做得很好——一个漂亮、干净的 Git 仓库。\n要注意的一点是并没有检出任何东西——一开始你的工作目录内并没有任何文件。\n为了得到他们，你必须将分支重置到 ","l":"\n","c":[{"n":"code","x":"master","l":" 所在的地方：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"$ ","l":"ls\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"git reset --hard master\nHEAD is now at 3caa046 imported from current\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"$ ","l":"ls\nREADME.md main.rb","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"可以通过 ","l":"\n","c":[{"n":"code","x":"fast-import","l":" 工具做很多事情——处理不同模式、二进制数据、多个分支与合并、标签、进度指示等等。\n一些更复杂情形下的例子可以在 Git 源代码目录中的 ","a":[["class","literal"]]},{"n":"code","x":"contrib/fast-import","l":" 目录中找到。","a":[["class","literal"]]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","总结"]],"c":[{"n":"h2","x":"总结","l":"\n","a":[["id","_总结"]]},{"n":"p","x":"你会觉得将 Git 作为其他版本控制系统的客户端，或者在数据无损的情况下将几乎任何一个现有的仓库导入到 Git，都是一件很惬意的事。\n在下一章，我们将要讲解 Git 的原始内部数据，如果需要的话你就可以加工每一个字节。","l":"\n"}]}]}]}]},"ns_map":["http://www.w3.org/1999/xhtml","http://www.w3.org/XML/1998/namespace","http://www.idpf.org/2007/ops"]}