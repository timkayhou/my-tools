{"version":1,"tree":{"n":"html","a":[["lang","zh",1],["lang","zh"]],"c":[{"n":"head","x":"\n\n","l":"\n","c":[{"n":"title","x":"在你的应用中嵌入 Git","l":"\n"},{"n":"link","l":"\n","a":[["rel","stylesheet"],["type","text/css"],["href","styles/epub3.css"]]},{"n":"link","l":"\n","a":[["rel","stylesheet"],["type","text/css"],["href","styles/epub3-css3-only.css"],["media","(min-device-width: 0px)"]]},{"n":"script","x":"\ndocument.addEventListener('DOMContentLoaded', function(event, reader) {\n  if (!(reader = navigator.epubReadingSystem)) {\n    if (navigator.userAgent.indexOf(' calibre/') >= 0) reader = { name: 'calibre-desktop' };\n    else if (window.parent == window || !(reader = window.parent.navigator.epubReadingSystem)) return;\n  }\n  document.body.setAttribute('class', reader.name.toLowerCase().replace(/ /g, '-'));\n});\n","l":"\n","a":[["type","text/javascript"]]}]},{"n":"body","x":"\n","l":"\n","c":[{"n":"section","x":"\n","l":"\n","a":[["class","chapter"],["title","在你的应用中嵌入 Git"],["type","chapter",2],["id","B-embedding-git-in-your-applications"]],"c":[{"n":"header","x":"\n","l":"\n","c":[{"n":"div","x":"\n","l":"\n","a":[["class","chapter-header"]],"c":[{"n":"h1","l":"\n","a":[["class","chapter-title"]],"c":[{"n":"small","a":[["class","subtitle"]],"c":[{"n":"b","x":"在你的应用中嵌入","l":" "},{"n":"b","x":"Git"}]}]}]}]},{"n":"p","x":"如果你的应用程序的目标用户是开发者，那么在其中集成源码控制功能会让他们从中受益。\n甚至对于文档编辑器等并非面向程序员的应用，也可以从版本控制系统中受益，Git 的工作模式在多种场景下表现得都非常出色。","l":"\n"},{"n":"p","x":"如果你想将 Git 整合进你的应用程序，那么通常有两种可行的选择：启动 shell 来调用 Git 的命令行程序，或者将 Git 库嵌入到你的应用中。","l":"\n"},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","命令行 Git 方式"]],"c":[{"n":"h2","x":"命令行 Git 方式","l":"\n","a":[["id","_命令行_git_方式"]]},{"n":"p","x":"一种方式就是启动一个 shell 进程并在里面使用 Git 的命令行工具来完成任务。\n这种方式看起来很循规蹈矩，但是它的优点也因此而来，就是支持所有的 Git 的特性。\n它也碰巧相当简单，因为几乎所有运行时环境都有一个相对简单的方式来调用一个带有命令行参数的进程。\n然而，这种方式也有一些固有的缺点。","l":"\n"},{"n":"p","x":"首先就是所有的输出都是纯文本格式。\n这意味着你将被迫解析 Git 的有时会改变的输出格式，以随时了解它工作的进度和结果。更糟糕的是，这可能是毫无效率并且容易出错的。","l":"\n"},{"n":"p","x":"另外一个就是令人捉急的错误修复能力。\n如果一个版本库被莫名其妙地损毁，或者用户使用了一个奇奇怪怪的配置， Git 只会简单地拒绝进行一些操作。","l":"\n"},{"n":"p","x":"还有一个就是进程的管理。\nGit 会要求你在一个独立的进程中维护一个 shell 环境，这可能会无谓地增加复杂性。\n试图协调许许多多的类似的进程（尤其是在某些情况下，当不同的进程在访问相同的版本库时）是对你的能力的极大挑战。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","Libgit2"]],"c":[{"n":"h2","x":"Libgit2","l":"\n","a":[["id","_libgit2"]]},{"n":"p","x":"©\n另外一种可以供你使用的是 Libgit2。\nLibgit2 是一个 Git 的非依赖性的工具，它致力于为其他程序使用 Git 提供更好的 API。\n你可以在 ","l":"\n","c":[{"n":"a","x":"https://libgit2.org","l":" 找到它。","a":[["href","https://libgit2.org"],["class","link"]]}]},{"n":"p","x":"首先，让我们来看一下 C API 长啥样。\n这是一个旋风式旅行。","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-c"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"// 打开一个版本库","l":"\ngit_repository *repo;\n","a":[["style","font-style: italic"]]},{"n":"span","x":"int","l":" error = git_repository_open(&repo, ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"/path/to/repository\"","l":");\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// 逆向引用 HEAD 到一个提交","l":"\ngit_object *head_commit;\nerror = git_revparse_single(&head_commit, repo, ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"HEAD^{commit}\"","l":");\ngit_commit *commit = (git_commit*)head_commit;\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// 显示这个提交的一些详情","l":"\nprintf(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"%s\"","l":", git_commit_message(commit));\n","a":[["style","font-style: italic"]]},{"n":"span","x":"const","l":" git_signature *author = git_commit_author(commit);\nprintf(","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"%s <%s>","a":[["style","font-style: italic"]]},{"n":"span","x":"\\n","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":"\"","l":", author->name, author->email);\n","a":[["style","font-style: italic"]]},{"n":"span","x":"const","l":" git_oid *tree_id = git_commit_tree_id(commit);\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"// 清理现场","l":"\ngit_commit_free(commit);\ngit_repository_free(repo);","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"前两行打开一个 Git 版本库。\n这个 ","l":"\n","c":[{"n":"code","x":"git_repository","l":" 类型代表了一个在内存中带有缓存的指向一个版本库的句柄。\n这是最简单的方法，只是你必须知道一个版本库的工作目录或者一个 ","a":[["class","literal"]]},{"n":"code","x":".git","l":" 文件夹的精确路径。\n另外还有 ","a":[["class","literal"]]},{"n":"code","x":"git_repository_open_ext","l":" ，它包括了带选项的搜索， ","a":[["class","literal"]]},{"n":"code","x":"git_clone","l":" 及其同类可以用来做远程版本库的本地克隆， ","a":[["class","literal"]]},{"n":"code","x":"git_repository_init","l":" 则可以创建一个全新的版本库。","a":[["class","literal"]]}]},{"n":"p","x":"第二段代码使用了一种 rev-parse 语法（要了解更多，请看 ","l":"\n","c":[{"n":"a","x":"分支引用","l":" ）来得到 HEAD 真正指向的提交。\n返回类型是一个 ","a":[["id","xref--ch07-git-tools--_branch_references"],["href","javascript:void(0)"],["class","xref"],["data-Z5ljfaarsuY3mMdpckH3E3","{\"name\": \"OEBPS/ch07-git-tools.xhtml\", \"frag\": \"_branch_references\"}"]]},{"n":"code","x":"git_object","l":" 指针，它指代位于版本库里的 Git 对象数据库中的某个东西。\n","a":[["class","literal"]]},{"n":"code","x":"git_object","l":" 实际上是几种不同的对象的“父”类型，每个“子”类型的内存布局和 ","a":[["class","literal"]]},{"n":"code","x":"git_object","l":" 是一样的，所以你能安全地把它们转换为正确的类型。\n在上面的例子中， ","a":[["class","literal"]]},{"n":"code","x":"git_object_type(commit)","l":" 会返回 ","a":[["class","literal"]]},{"n":"code","x":"GIT_OBJ_COMMIT","l":" ，所以转换成 ","a":[["class","literal"]]},{"n":"code","x":"git_commit","l":" 指针是安全的。","a":[["class","literal"]]}]},{"n":"p","x":"下一段展示了如何访问一个提交的详情。\n最后一行使用了 ","l":"\n","c":[{"n":"code","x":"git_oid","l":" 类型，这是 Libgit2 用来表示一个 SHA-1 哈希的方法。","a":[["class","literal"]]}]},{"n":"p","x":"从这个例子中，我们可以看到一些模式：","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","itemized-list"]],"c":[{"n":"ul","x":"\n","l":"\n","c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"如果你声明了一个指针，并在一个 Libgit2 调用中传递一个引用，那么这个调用可能返回一个 int 类型的错误码。\n值 ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":"0","l":" 表示成功，比它小的则是一个错误。","a":[["class","literal"]]}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"如果 Libgit2 为你填入一个指针，那么你有责任释放它。","l":"\n","a":[["class","principal"]]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"如果 Libgit2 在一个调用中返回一个 ","l":"\n","a":[["class","principal"]],"c":[{"n":"code","x":"const","l":" 指针，你不需要释放它，但是当它所指向的对象被释放时它将不可用。","a":[["class","literal"]]}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"用 C 来写有点蛋疼。","l":"\n","a":[["class","principal"]]}]}]}]},{"n":"p","x":"\n最后一点意味着你应该不会在使用 Libgit2 时编写 C 语言程序。\n但幸运的是，有许多可用的各种语言的绑定，能让你在特定的语言和环境中更加容易的操作 Git 版本库。\n我们来看一下下面这个用 Libgit2 的 Ruby 绑定写成的例子，它叫 Rugged，你可以在 ","l":"\n","c":[{"n":"a","x":"https://github.com/libgit2/rugged","l":" 找到它。","a":[["href","https://github.com/libgit2/rugged"],["class","link"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"repo = Rugged::Repository.new("},{"n":"span","x":"'path/to/repository'","l":")\ncommit = repo.head.target\nputs commit.message\nputs ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"commit.author[","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":":name","l":"]","a":[["style","font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":" <","a":[["style","font-style: italic"]]},{"n":"span","x":"#{","l":"commit.author[","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":":email","l":"]","a":[["style","font-style: italic"]]},{"n":"span","x":"}","a":[["style","font-weight: bold; font-style: italic"]]},{"n":"span","x":">\"","l":"\ntree = commit.tree","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"你可以发现，代码看起来更加清晰了。\n首先， Rugged 使用异常机制，它可以抛出类似于 ","l":"\n","c":[{"n":"code","x":"ConfigError","l":" 或者 ","a":[["class","literal"]]},{"n":"code","x":"ObjectError","l":" 之类的东西来告知错误的情况。\n其次，不需要明确资源释放，因为 Ruby 是支持垃圾回收的。\n我们来看一个稍微复杂一点的例子：从头开始制作一个提交。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-ruby"]],"c":[{"n":"code","c":[{"n":"span","l":"blob_id = repo.write("},{"n":"span","x":"\"Blob contents\"","l":", ","a":[["style","font-style: italic"]]},{"n":"span","x":":blob","l":") ","a":[["style","font-style: italic"]]},{"n":"i","x":"①","l":"\n\nindex = repo.index\nindex.read_tree(repo.head.target.tree)\nindex.add(","a":[["class","conum"],["data-value","1"]]},{"n":"span","x":":path","l":" => ","a":[["style","font-style: italic"]]},{"n":"span","x":"'newfile.txt'","l":", ","a":[["style","font-style: italic"]]},{"n":"span","x":":oid","l":" => blob_id) ","a":[["style","font-style: italic"]]},{"n":"i","x":"②","l":"\n\nsig = {\n    ","a":[["class","conum"],["data-value","2"]]},{"n":"span","x":":email","l":" => ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"bob@example.com\"","l":",\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":":name","l":" => ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"Bob User\"","l":",\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":":time","l":" => Time.now,\n}\n\ncommit_id = Rugged::Commit.create(repo,\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":":tree","l":" => index.write_tree(repo), ","a":[["style","font-style: italic"]]},{"n":"i","x":"③","l":"\n    ","a":[["class","conum"],["data-value","3"]]},{"n":"span","x":":author","l":" => sig,\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":":committer","l":" => sig, ","a":[["style","font-style: italic"]]},{"n":"i","x":"④","l":"\n    ","a":[["class","conum"],["data-value","4"]]},{"n":"span","x":":message","l":" => ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"Add newfile.txt\"","l":", ","a":[["style","font-style: italic"]]},{"n":"i","x":"⑤","l":"\n    ","a":[["class","conum"],["data-value","5"]]},{"n":"span","x":":parents","l":" => repo.empty? ? [] : [ repo.head.target ].compact, ","a":[["style","font-style: italic"]]},{"n":"i","x":"⑥","l":"\n    ","a":[["class","conum"],["data-value","6"]]},{"n":"span","x":":update_ref","l":" => ","a":[["style","font-style: italic"]]},{"n":"span","x":"'HEAD'","l":", ","a":[["style","font-style: italic"]]},{"n":"i","x":"⑦","l":"\n)\ncommit = repo.lookup(commit_id) ","a":[["class","conum"],["data-value","7"]]},{"n":"i","x":"⑧","a":[["class","conum"],["data-value","8"]]}]}]}]},{"n":"div","x":"\n","l":"\n","a":[["class","callout-list"]],"c":[{"n":"ol","x":"\n","l":"\n","c":[{"n":"li","l":"\n","c":[{"n":"i","x":"①","l":" 创建一个新的 blob ，它包含了一个新文件的内容。","a":[["class","conum"],["data-value","1"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"②","l":" 将 HEAD 提交树填入索引，并在路径 ","a":[["class","conum"],["data-value","2"]]},{"n":"code","x":"newfile.txt","l":" 增加新文件。","a":[["class","literal"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"③","l":" 这就在 ODB 中创建了一个新的树，并在一个新的提交中使用它。","a":[["class","conum"],["data-value","3"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"④","l":" 我们在 author 栏和 committer 栏使用相同的签名。","a":[["class","conum"],["data-value","4"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"⑤","l":" 提交的信息。","a":[["class","conum"],["data-value","5"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"⑥","l":" 当创建一个提交时，你必须指定这个新提交的父提交。\n这里使用了 HEAD 的末尾作为单一的父提交。","a":[["class","conum"],["data-value","6"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"⑦","l":" 在做一个提交的过程中， Rugged （和 Libgit2 ）能在需要时更新引用。","a":[["class","conum"],["data-value","7"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"⑧","l":" 返回值是一个新提交对象的 SHA-1 哈希，你可以用它来获得一个 ","a":[["class","conum"],["data-value","8"]]},{"n":"code","x":"Commit","l":" 对象。","a":[["class","literal"]]}]}]}]},{"n":"p","x":"Ruby 的代码很好很简洁，另一方面因为 Libgit2 做了大量工作，所以代码运行起来其实速度也不赖。\n如果你不是一个 Ruby 程序员，我们在 ","l":"\n","c":[{"n":"a","x":"其它绑定","l":" 有提到其它的一些绑定。","a":[["id","xref-_libgit2_bindings"],["href","javascript:void(0)"],["class","xref"],["data-Z5ljfaarsuY3mMdpckH3E3","{\"name\": \"OEBPS/B-embedding-git-in-your-applications.xhtml\", \"frag\": \"_libgit2_bindings\"}"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","高级功能"]],"c":[{"n":"h3","x":"高级功能","l":"\n","a":[["id","_高级功能"]]},{"n":"p","x":"Libgit2 有几个超过核心 Git 的能力。\n例如它的可定制性：Libgit2 允许你为一些不同类型的操作自定义的“后端”，让你得以使用与原生 Git 不同的方式存储东西。\nLibgit2 允许为自定义后端指定配置、引用的存储以及对象数据库，","l":"\n"},{"n":"p","x":"我们来看一下它究竟是怎么工作的。\n下面的例子借用自 Libgit2 团队提供的后端样本集 （可以在 ","l":"\n","c":[{"n":"a","x":"https://github.com/libgit2/libgit2-backends","l":" 上找到）。\n一个对象数据库的自定义后端是这样建立的：","a":[["href","https://github.com/libgit2/libgit2-backends"],["class","link"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-c"]],"c":[{"n":"code","c":[{"n":"span","l":"git_odb *odb;\n"},{"n":"span","x":"int","l":" error = git_odb_new(&odb); ","a":[["style","font-weight: bold"]]},{"n":"i","x":"①","l":"\n\ngit_odb_backend *my_backend;\nerror = git_odb_backend_mine(&my_backend, ","a":[["class","conum"],["data-value","1"]]},{"n":"span","x":"/*…*/","l":"); ","a":[["style","font-style: italic"]]},{"n":"i","x":"②","l":"\n\nerror = git_odb_add_backend(odb, my_backend, 1); ","a":[["class","conum"],["data-value","2"]]},{"n":"i","x":"③","l":"\n\ngit_repository *repo;\nerror = git_repository_open(&repo, ","a":[["class","conum"],["data-value","3"]]},{"n":"span","x":"\"some-path\"","l":");\nerror = git_repository_set_odb(repo, odb); ","a":[["style","font-style: italic"]]},{"n":"i","x":"④","a":[["class","conum"],["data-value","4"]]}]}]}]},{"n":"p","l":"\n","c":[{"n":"em","x":"（注意：这个错误被捕获了，但是没有被处理。我们希望你的代码比我们的更好。）"}]},{"n":"div","x":"\n","l":"\n","a":[["class","callout-list"]],"c":[{"n":"ol","x":"\n","l":"\n","c":[{"n":"li","l":"\n","c":[{"n":"i","x":"①","l":" 初始化一个空的对象数据库（ ODB ）“前端”，它将被作为一个用来做真正的工作的“后端”的容器。","a":[["class","conum"],["data-value","1"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"②","l":" 初始化一个自定义 ODB 后端。","a":[["class","conum"],["data-value","2"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"③","l":" 为这个前端增加一个后端。","a":[["class","conum"],["data-value","3"]]}]},{"n":"li","l":"\n","c":[{"n":"i","x":"④","l":" 打开一个版本库，并让它使用我们的 ODB 来寻找对象。","a":[["class","conum"],["data-value","4"]]}]}]}]},{"n":"p","x":"但是 ","l":"\n","c":[{"n":"code","x":"git_odb_backend_mine","l":" 是个什么东西呢？\n嗯，那是一个你自己的 ODB 实现的构造器，并且你能在那里做任何你想做的事，前提是你能正确地填写 ","a":[["class","literal"]]},{"n":"code","x":"git_odb_backend","l":" 结构。\n它看起来_应该_是这样的：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-c"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"typedef","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"struct","l":" {\n    git_odb_backend parent;\n\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"// 其它的一些东西","l":"\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":"void","l":" *custom_context;\n} my_backend_struct;\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"int","l":" git_odb_backend_mine(git_odb_backend **backend_out, ","a":[["style","font-weight: bold"]]},{"n":"span","x":"/*…*/","l":")\n{\n    my_backend_struct *backend;\n\n    backend = calloc(1, ","a":[["style","font-style: italic"]]},{"n":"span","x":"sizeof","l":" (my_backend_struct));\n\n    backend->custom_context = ","a":[["style","font-weight: bold"]]},{"n":"span","x":"…","l":";\n\n    backend->parent.read = &my_backend__read;\n    backend->parent.read_prefix = &my_backend__read_prefix;\n    backend->parent.read_header = &my_backend__read_header;\n    ","a":[["style","border: 1px solid #FF0000"]]},{"n":"span","x":"// ……","l":"\n\n    *backend_out = (git_odb_backend *) backend;\n\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":"return","l":" GIT_SUCCESS;\n}","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","l":"\n","c":[{"n":"code","x":"my_backend_struct","l":" 的第一个成员必须是一个 ","a":[["class","literal"]]},{"n":"code","x":"git_odb_backend","l":" 结构，这是一个微妙的限制：这样就能确保内存布局是 Libgit2 的代码所期望的样子。\n其余都是随意的，这个结构的大小可以随心所欲。","a":[["class","literal"]]}]},{"n":"p","x":"这个初始化函数为该结构分配内存，设置自定义的上下文，然后填写它支持的 ","l":"\n","c":[{"n":"code","x":"parent","l":" 结构的成员。\n阅读 Libgit2 的 ","a":[["class","literal"]]},{"n":"code","x":"include/git2/sys/odb_backend.h","l":" 源码以了解全部调用签名，你特定的使用环境会帮你决定使用哪一种调用签名。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","其它绑定"]],"c":[{"n":"h3","x":"其它绑定","l":"\n","a":[["id","_libgit2_bindings"]]},{"n":"p","x":"Libgit2 有很多种语言的绑定。\n在这篇文章中，我们展现了一个使用了几个更加完整的绑定包的小例子，这些库存在于许多种语言中，包括 C++、Go、Node.js、Erlang 以及 JVM ，它们的成熟度各不相同。\n官方的绑定集合可以通过浏览这个版本库得到： ","l":"\n","c":[{"n":"a","x":"https://github.com/libgit2","l":" 。\n我们写的代码将返回当前 HEAD 指向的提交的提交信息（就像 ","a":[["href","https://github.com/libgit2"],["class","link"]]},{"n":"code","x":"git log -1","l":" 那样）。","a":[["class","literal"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","LibGit2Sharp"]],"c":[{"n":"h4","x":"LibGit2Sharp","l":"\n","a":[["id","_libgit2sharp"]]},{"n":"p","x":"\n如果你在编写一个 .NET 或者 Mono 应用，那么 LibGit2Sharp (","l":"\n","c":[{"n":"a","x":"https://github.com/libgit2/libgit2sharp","l":") 就是你所需要的。\n这个绑定是用 C# 写成的，并且已经采取许多措施来用令人感到自然的 CLR API 包装原始的 Libgit2 的调用。\n我们的例子看起来就像这样：","a":[["href","https://github.com/libgit2/libgit2sharp"],["class","link"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-csharp"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"new","l":" Repository(","a":[["style","font-weight: bold"]]},{"n":"span","x":"@\"C:\\path\\to\\repo\"","l":").Head.Tip.Message;","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"对于 Windows 桌面应用，一个叫做 NuGet 的包会让你快速上手。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","objective-git"]],"c":[{"n":"h4","x":"objective-git","l":"\n","a":[["id","_objective_git"]]},{"n":"p","x":"\n如果你的应用运行在一个 Apple 平台上，你很有可能使用 Objective-C 作为实现语言。\nObjective-Git (","l":"\n","c":[{"n":"a","x":"https://github.com/libgit2/objective-git","l":") 是这个环境下的 Libgit2 绑定。\n一个例子看起来类似这样：","a":[["href","https://github.com/libgit2/objective-git"],["class","link"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-objc"]],"c":[{"n":"code","c":[{"n":"span","l":"GTRepository *repo =\n    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: "},{"n":"span","x":"@\"/path/to/repo\"","l":"] error:NULL];\nNSString *msg = [[[epo headReferenceWithError:NULL] resolvedTarget] message];","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"Objective-git 与 Swift 完美兼容，所以你把 Objective-C 落在一边的时候不用恐惧。","l":"\n"}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect3"],["title","pygit2"]],"c":[{"n":"h4","x":"pygit2","l":"\n","a":[["id","_pygit2"]]},{"n":"p","x":"\nPython 的 Libgit2 绑定叫做 Pygit2 ，你可以在 ","l":"\n","c":[{"n":"a","x":"https://www.pygit2.org/","l":" 找到它。\n我们的示例程序：","a":[["href","https://www.pygit2.org/"],["class","link"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-python"]],"c":[{"n":"code","c":[{"n":"span","l":"pygit2.Repository("},{"n":"span","x":"\"/path/to/repo\"","l":") ","a":[["style","font-style: italic"]]},{"n":"span","x":"# 打开代码仓库","l":"\n    .head                          ","a":[["style","font-style: italic"]]},{"n":"span","x":"# 获取当前分支","l":"\n    .peel(pygit2.Commit)           ","a":[["style","font-style: italic"]]},{"n":"span","x":"# 找到对应的提交","l":"\n    .message                       ","a":[["style","font-style: italic"]]},{"n":"span","x":"# 读取提交信息","a":[["style","font-style: italic"]]}]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","扩展阅读"]],"c":[{"n":"h3","x":"扩展阅读","l":"\n","a":[["id","_扩展阅读"]]},{"n":"p","x":"当然，完全阐述 Libgit2 的能力已超出本书范围。\n如果你想了解更多关于 Libgit2 的信息，可以浏览它的 API 文档： ","l":"\n","c":[{"n":"a","x":"https://libgit2.github.com/libgit2","l":", 以及一系列的指南： ","a":[["href","https://libgit2.github.com/libgit2"],["class","link"]]},{"n":"a","x":"https://libgit2.github.com/docs","l":".\n对于其它的绑定，检查附带的 README 和测试文件，那里通常有简易教程，以及指向拓展阅读的链接。","a":[["href","https://libgit2.github.com/docs"],["class","link"]]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","JGit"]],"c":[{"n":"h2","x":"JGit","l":"\n","a":[["id","_jgit"]]},{"n":"p","x":"\n如果你想在一个 Java 程序中使用 Git ，有一个功能齐全的 Git 库，那就是 JGit 。\nJGit 是一个用 Java 写成的功能相对健全的 Git 的实现，它在 Java 社区中被广泛使用。\nJGit 项目由 Eclipse 维护，它的主页在 ","l":"\n","c":[{"n":"a","x":"https://www.eclipse.org/jgit","l":" 。","a":[["href","https://www.eclipse.org/jgit"],["class","link"]]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","起步"]],"c":[{"n":"h3","x":"起步","l":"\n","a":[["id","_起步"]]},{"n":"p","x":"有很多种方式可以让 JGit 连接你的项目，并依靠它去写代码。\n最简单的方式也许就是使用 Maven 。你可以通过在你的 pom.xml 文件里的 ","l":"\n","c":[{"n":"code","x":"<dependencies>","l":" 标签中增加像下面这样的片段来完成这个整合。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-xml"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"<dependency>","l":"\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"<groupId>","l":"org.eclipse.jgit","a":[["style","font-weight: bold"]]},{"n":"span","x":"</groupId>","l":"\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"<artifactId>","l":"org.eclipse.jgit","a":[["style","font-weight: bold"]]},{"n":"span","x":"</artifactId>","l":"\n    ","a":[["style","font-weight: bold"]]},{"n":"span","x":"<version>","l":"3.5.0.201409260305-r","a":[["style","font-weight: bold"]]},{"n":"span","x":"</version>","l":"\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"</dependency>","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"在你读到这段文字时 ","l":"\n","c":[{"n":"code","x":"version","l":" 很可能已经更新了，所以请浏览 ","a":[["class","literal"]]},{"n":"a","x":"https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit","l":" 以获取最新的仓库信息。\n当这一步完成之后， Maven 就会自动获取并使用你所需要的 JGit 库。","a":[["href","https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit"],["class","link"]]}]},{"n":"p","x":"如果你想自己管理二进制的依赖包，那么你可以从 ","l":"\n","c":[{"n":"a","x":"https://www.eclipse.org/jgit/download","l":" 获得预构建的 JGit 二进制文件。\n你可以像下面这样执行一个命令来将它们构建进你的项目。","a":[["href","https://www.eclipse.org/jgit/download"],["class","link"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-console"]],"c":[{"n":"code","c":[{"n":"span","l":"javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java\njava -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App"}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","底层命令"]],"c":[{"n":"h3","x":"底层命令","l":"\n","a":[["id","_底层命令"]]},{"n":"p","x":"JGit 的 API 有两种基本的层次：底层命令和高层命令。\n这个两个术语都来自 Git ，并且 JGit 也被按照相同的方式粗略地划分：高层 API 是一个面向普通用户级别功能的友好的前端（一系列普通用户使用 Git 命令行工具时可能用到的东西），底层 API 则直接作用于低级的仓库对象。","l":"\n"},{"n":"p","x":"大多数 JGit 会话会以 ","l":"\n","c":[{"n":"code","x":"Repository","l":" 类作为起点，你首先要做的事就是创建一个它的实例。\n对于一个基于文件系统的仓库来说（嗯， JGit 允许其它的存储模型），用 ","a":[["class","literal"]]},{"n":"code","x":"FileRepositoryBuilder","l":" 完成它。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-java"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"// 创建一个新仓库","l":"\nRepository newlyCreatedRepo = FileRepositoryBuilder.create(\n    ","a":[["style","font-style: italic"]]},{"n":"span","x":"new","l":" File(","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"/tmp/new_repo/.git\"","l":"));\nnewlyCreatedRepo.create();\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// 打开一个存在的仓库","l":"\nRepository existingRepo = ","a":[["style","font-style: italic"]]},{"n":"span","x":"new","l":" FileRepositoryBuilder()\n    .setGitDir(","a":[["style","font-weight: bold"]]},{"n":"span","x":"new","l":" File(","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"my_repo/.git\"","l":"))\n    .build();","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"无论你的程序是否知道仓库的确切位置，builder 中的那个流畅的 API 都可以提供给它寻找仓库所需所有信息。\n它可以使用环境变量 （","l":"\n","c":[{"n":"code","x":".readEnvironment()","l":"） ，从工作目录的某处开始并搜索 （","a":[["class","literal"]]},{"n":"code","x":".setWorkTree(…).findGitDir()","l":"） , 或者仅仅只是像上面那样打开一个已知的 ","a":[["class","literal"]]},{"n":"code","x":".git","l":" 目录。","a":[["class","literal"]]}]},{"n":"p","x":"当你拥有一个 ","l":"\n","c":[{"n":"code","x":"Repository","l":" 实例后，你就能对它做各种各样的事。\n下面是一个速览：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-java"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"// 获取引用","l":"\nRef master = repo.getRef(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"master\"","l":");\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// 获取该引用所指向的对象","l":"\nObjectId masterTip = master.getObjectId();\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// Rev-parse","l":"\nObjectId obj = repo.resolve(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"HEAD^{tree}\"","l":");\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// 装载对象原始内容","l":"\nObjectLoader loader = repo.open(masterTip);\nloader.copyTo(System.out);\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// 创建分支","l":"\nRefUpdate createBranch1 = repo.updateRef(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"refs/heads/branch1\"","l":");\ncreateBranch1.setNewObjectId(masterTip);\ncreateBranch1.update();\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// 删除分支","l":"\nRefUpdate deleteBranch1 = repo.updateRef(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"refs/heads/branch1\"","l":");\ndeleteBranch1.setForceUpdate(","a":[["style","font-style: italic"]]},{"n":"span","x":"true","l":");\ndeleteBranch1.delete();\n\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"// 配置","l":"\nConfig cfg = repo.getConfig();\nString name = cfg.getString(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"user\"","l":", ","a":[["style","font-style: italic"]]},{"n":"span","x":"null","l":", ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"name\"","l":");","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"这里完成了一大堆事情，所以我们还是一次理解一段的好。","l":"\n"},{"n":"p","x":"第一行获取一个指向 ","l":"\n","c":[{"n":"code","x":"master","l":" 引用的指针。\nJGit 自动抓取位于 ","a":[["class","literal"]]},{"n":"code","x":"refs/heads/master","l":" 的 ","a":[["class","literal"]]},{"n":"em","x":"真正的","l":" "},{"n":"code","x":"master","l":" 引用，并返回一个允许你获取该引用的信息的对象。\n你可以获取它的名字 （","a":[["class","literal"]]},{"n":"code","x":".getName()","l":"） ，或者一个直接引用的目标对象 （","a":[["class","literal"]]},{"n":"code","x":".getObjectId()","l":"） ，或者一个指向该引用的符号指针 （","a":[["class","literal"]]},{"n":"code","x":".getTarget()","l":"） 。\n引用对象也经常被用来表示标签的引用和对象，所以你可以询问某个标签是否被“削除”了，或者说它指向一个标签对象的（也许很长的）字符串的最终目标。","a":[["class","literal"]]}]},{"n":"p","x":"第二行获得以 ","l":"\n","c":[{"n":"code","x":"master","l":" 引用的目标，它返回一个 ObjectId 实例。\n不管是否存在于一个 Git 对象的数据库，ObjectId 都会代表一个对象的 SHA-1 哈希。\n第三行与此相似，但是它展示了 JGit 如何处理 rev-parse 语法（要了解更多，请看 ","a":[["class","literal"]]},{"n":"a","x":"分支引用","l":" ），你可以传入任何 Git 了解的对象说明符，然后 JGit 会返回该对象的一个有效的 ObjectId ，或者 ","a":[["href","javascript:void(0)"],["class","xref"],["data-Z5ljfaarsuY3mMdpckH3E3","{\"name\": \"OEBPS/ch07-git-tools.xhtml\", \"frag\": \"_branch_references\"}"]]},{"n":"code","x":"null","l":" 。","a":[["class","literal"]]}]},{"n":"p","x":"接下来两行展示了如何装载一个对象的原始内容。\n在这个例子中，我们调用 ","l":"\n","c":[{"n":"code","x":"ObjectLoader.copyTo()","l":" 直接向标准输出流输出对象的内容，除此之外 ObjectLoader 还带有读取对象的类型和长度并将它以字节数组返回的方法。\n对于一个（ ","a":[["class","literal"]]},{"n":"code","x":".isLarge()","l":" 返回 ","a":[["class","literal"]]},{"n":"code","x":"true","l":" 的）大的对象，你可以调用 ","a":[["class","literal"]]},{"n":"code","x":".openStream()","l":" 来获得一个类似 InputStream 的对象，它可以在没有一次性将所有数据拉到内存的前提下读取对象的原始数据。","a":[["class","literal"]]}]},{"n":"p","x":"接下来几行展现了如何创建一个新的分支。\n我们创建一个 RefUpdate 实例，配置一些参数，然后调用 ","l":"\n","c":[{"n":"code","x":".update()","l":" 来确认这个更改。\n删除相同分支的代码就在这行下面。\n记住必须先 ","a":[["class","literal"]]},{"n":"code","x":".setForceUpdate(true)","l":" 才能让它工作，否则调用 ","a":[["class","literal"]]},{"n":"code","x":".delete()","l":" 只会返回 ","a":[["class","literal"]]},{"n":"code","x":"REJECTED","l":" ，然后什么都没有发生。","a":[["class","literal"]]}]},{"n":"p","x":"最后一个例子展示了如何从 Git 配置文件中获取 ","l":"\n","c":[{"n":"code","x":"user.name","l":" 的值。\n这个 Config 实例使用我们先前打开的仓库做本地配置，但是它也会自动地检测并读取全局和系统的配置文件。","a":[["class","literal"]]}]},{"n":"p","x":"这只是底层 API 的冰山一角，另外还有许多可以使用的方法和类。\n还有一个没有放在这里说明的，就是 JGit 是用异常机制来处理错误的。\nJGit API 有时使用标准的 Java 异常（例如 ","l":"\n","c":[{"n":"code","x":"IOException","l":" ），但是它也提供了大量 JGit 自己定义的异常类型（例如 ","a":[["class","literal"]]},{"n":"code","x":"NoRemoteRepositoryException","l":"、 ","a":[["class","literal"]]},{"n":"code","x":"CorruptObjectException","l":" 和 ","a":[["class","literal"]]},{"n":"code","x":"NoMergeBaseException","l":"）。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","高层命令"]],"c":[{"n":"h3","x":"高层命令","l":"\n","a":[["id","_高层命令"]]},{"n":"p","x":"底层 API 更加完善，但是有时将它们串起来以实现普通的目的非常困难，例如将一个文件添加到索引，或者创建一个新的提交。\n为了解决这个问题， JGit 提供了一系列高层 API ，使用这些 API 的入口点就是 ","l":"\n","c":[{"n":"code","x":"Git","l":" 类：","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-java"]],"c":[{"n":"code","c":[{"n":"span","l":"Repository repo;\n"},{"n":"span","x":"// 构建仓库……","l":"\nGit git = ","a":[["style","font-style: italic"]]},{"n":"span","x":"new","l":" Git(repo);","a":[["style","font-weight: bold"]]}]}]}]},{"n":"p","x":"Git 类有一系列非常好的 ","l":"\n","c":[{"n":"em","x":"构建器","l":" 风格的高层方法，它可以用来构造一些复杂的行为。\n我们来看一个例子——做一件类似 "},{"n":"code","x":"git ls-remote","l":" 的事。","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-java"]],"c":[{"n":"code","c":[{"n":"span","l":"CredentialsProvider cp = "},{"n":"span","x":"new","l":" UsernamePasswordCredentialsProvider(","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"username\"","l":", ","a":[["style","font-style: italic"]]},{"n":"span","x":"\"p4ssw0rd\"","l":");\nCollection<Ref> remoteRefs = git.lsRemote()\n    .setCredentialsProvider(cp)\n    .setRemote(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"origin\"","l":")\n    .setTags(","a":[["style","font-style: italic"]]},{"n":"span","x":"true","l":")\n    .setHeads(","a":[["style","font-weight: bold"]]},{"n":"span","x":"false","l":")\n    .call();\n","a":[["style","font-weight: bold"]]},{"n":"span","x":"for","l":" (Ref ref : remoteRefs) {\n    System.out.println(ref.getName() + ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\" -> \"","l":" + ref.getObjectId().name());\n}","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"这是一个 Git 类的公共样式，这个方法返回一个可以让你串连若干方法调用来设置参数的命令对象，当你调用 ","l":"\n","c":[{"n":"code","x":".call()","l":" 时它们就会被执行。\n在这情况下，我们只是请求了 ","a":[["class","literal"]]},{"n":"code","x":"origin","l":" 远程的标签，而不是头部。\n还要注意用于验证的 ","a":[["class","literal"]]},{"n":"code","x":"CredentialsProvider","l":" 对象的使用。","a":[["class","literal"]]}]},{"n":"p","x":"在 Git 类中还可以使用许多其它的命令，包括但不限于 ","l":"\n","c":[{"n":"code","x":"add","l":"、","a":[["class","literal"]]},{"n":"code","x":"blame","l":"、","a":[["class","literal"]]},{"n":"code","x":"commit","l":"、","a":[["class","literal"]]},{"n":"code","x":"clean","l":"、","a":[["class","literal"]]},{"n":"code","x":"push","l":"、","a":[["class","literal"]]},{"n":"code","x":"rebase","l":"、","a":[["class","literal"]]},{"n":"code","x":"revert","l":" 和 ","a":[["class","literal"]]},{"n":"code","x":"reset","l":"。","a":[["class","literal"]]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","拓展阅读"]],"c":[{"n":"h3","x":"拓展阅读","l":"\n","a":[["id","_拓展阅读"]]},{"n":"p","x":"这只是 JGit 的全部能力的冰山一角。\n如果你对这有兴趣并且想深入学习，在下面可以找到一些信息和灵感。","l":"\n"},{"n":"div","x":"\n","l":"\n","a":[["class","itemized-list"]],"c":[{"n":"ul","x":"\n","l":"\n","c":[{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"JGit API 在线官方文档： ","l":"\n","a":[["class","principal"]],"c":[{"n":"a","x":"https://www.eclipse.org/jgit/documentation","l":" 。\n这是基本的 Javadoc ，所以你也可以在你最喜欢的 JVM IDE 上将它们安装它们到本地。","a":[["href","https://www.eclipse.org/jgit/documentation"],["class","link"]]}]}]},{"n":"li","x":"\n","l":"\n","c":[{"n":"span","x":"JGit Cookbook ： ","l":"\n","a":[["class","principal"]],"c":[{"n":"a","x":"https://github.com/centic9/jgit-cookbook","l":" 拥有许多如何利用 JGit 实现特定任务的例子。","a":[["href","https://github.com/centic9/jgit-cookbook"],["class","link"]]}]}]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","go-git"]],"c":[{"n":"h2","x":"go-git","l":"\n","a":[["id","_go_git"]]},{"n":"p","x":"\nIn case you want to integrate Git into a service written in Golang, there also is a pure Go library implementation.\nThis implementation does not have any native dependencies and thus is not prone to manual memory management errors.\nIt is also transparent for the standard Golang performance analysis tooling like CPU, Memory profilers, race detector, etc.","l":"\n"},{"n":"p","x":"go-git is focused on extensibility, compatibility and supports most of the plumbing APIs, which is documented at ","l":"\n","c":[{"n":"a","x":"https://github.com/src-d/go-git/blob/master/COMPATIBILITY.md","l":".","a":[["href","https://github.com/src-d/go-git/blob/master/COMPATIBILITY.md"],["class","link"]]}]},{"n":"p","x":"Here is a basic example of using Go APIs:","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-go"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"import","l":" \t","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"gopkg.in/src-d/go-git.v4\"","l":"\n\nr, err := git.PlainClone(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"/tmp/foo\"","l":", ","a":[["style","font-style: italic"]]},{"n":"span","x":"false","l":", &git.CloneOptions{\n    URL:      ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"https://github.com/src-d/go-git\"","l":",\n    Progress: os.Stdout,\n})","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"As soon as you have a ","l":"\n","c":[{"n":"code","x":"Repository","l":" instance, you can access information and perform mutations on it:","a":[["class","literal"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-go"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"// retrieves the branch pointed by HEAD","l":"\nref, err := r.Head()\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// get the commit object, pointed by ref","l":"\ncommit, err := r.CommitObject(ref.Hash())\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// retrieves the commit history","l":"\nhistory, err := commit.History()\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// iterates over the commits and print each","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"for","l":" _, c := ","a":[["style","font-weight: bold"]]},{"n":"span","x":"range","l":" history {\n    fmt.Println(c)\n}","a":[["style","font-weight: bold"]]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Advanced Functionality"]],"c":[{"n":"h3","x":"Advanced Functionality","l":"\n","a":[["id","_advanced_functionality"]]},{"n":"p","x":"go-git has few notable advanced features, one of which is a pluggable storage system, which is similar to Libgit2 backends.\nThe default implementation is in-memory storage, which is very fast.","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-go"]],"c":[{"n":"code","c":[{"n":"span","l":"r, err := git.Clone(memory.NewStorage(), "},{"n":"span","x":"nil","l":", &git.CloneOptions{\n    URL: ","a":[["style","font-weight: bold"]]},{"n":"span","x":"\"https://github.com/src-d/go-git\"","l":",\n})","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"Pluggable storage provides many interesting options.\nFor instance, ","l":"\n","c":[{"n":"a","x":"https://github.com/src-d/go-git/tree/master/_examples/storage","l":" allows you to store references, objects, and configuration in an Aerospike database.","a":[["href","https://github.com/src-d/go-git/tree/master/_examples/storage"],["class","link"]]}]},{"n":"p","x":"Another feature is a flexible filesystem abstraction.\nUsing ","l":"\n","c":[{"n":"a","x":"https://godoc.org/github.com/src-d/go-billy#Filesystem","l":" it is easy to store all the files in different way i.e by packing all of them to a single archive on disk or by keeping them all in-memory.","a":[["href","https://godoc.org/github.com/src-d/go-billy#Filesystem"],["class","link"]]}]},{"n":"p","x":"Another advanced use-case includes a fine-tunable HTTP client, such as the one found at ","l":"\n","c":[{"n":"a","x":"https://github.com/src-d/go-git/blob/master/_examples/custom_http/main.go","l":".","a":[["href","https://github.com/src-d/go-git/blob/master/_examples/custom_http/main.go"],["class","link"]]}]},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-go"]],"c":[{"n":"code","c":[{"n":"span","l":"customClient := &http.Client{\n\tTransport: &http.Transport{ "},{"n":"span","x":"// accept any certificate (might be useful for testing)","l":"\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: ","a":[["style","font-style: italic"]]},{"n":"span","x":"true","l":"},\n\t},\n\tTimeout: 15 * time.Second,  ","a":[["style","font-weight: bold"]]},{"n":"span","x":"// 15 second timeout","l":"\n\t\tCheckRedirect: ","a":[["style","font-style: italic"]]},{"n":"span","x":"func","l":"(req *http.Request, via []*http.Request) ","a":[["style","font-weight: bold"]]},{"n":"span","x":"error","l":" {\n\t\t","a":[["style","font-weight: bold"]]},{"n":"span","x":"return","l":" http.ErrUseLastResponse ","a":[["style","font-weight: bold"]]},{"n":"span","x":"// don't follow redirect","l":"\n\t},\n}\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// Override http(s) default protocol to use our custom client","l":"\nclient.InstallProtocol(","a":[["style","font-style: italic"]]},{"n":"span","x":"\"https\"","l":", githttp.NewClient(customClient))\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"// Clone repository using the new client if the protocol is https://","l":"\nr, err := git.Clone(memory.NewStorage(), ","a":[["style","font-style: italic"]]},{"n":"span","x":"nil","l":", &git.CloneOptions{URL: url})","a":[["style","font-weight: bold"]]}]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Further Reading"]],"c":[{"n":"h3","x":"Further Reading","l":"\n","a":[["id","_further_reading"]]},{"n":"p","x":"A full treatment of go-git’s capabilities is outside the scope of this book.\nIf you want more information on go-git, there’s API documentation at ","l":"\n","c":[{"n":"a","x":"https://godoc.org/gopkg.in/src-d/go-git.v4","l":", and a set of usage examples at ","a":[["href","https://godoc.org/gopkg.in/src-d/go-git.v4"],["class","link"]]},{"n":"a","x":"https://github.com/src-d/go-git/tree/master/_examples","l":".","a":[["href","https://github.com/src-d/go-git/tree/master/_examples"],["class","link"]]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect1"],["title","Dulwich"]],"c":[{"n":"h2","x":"Dulwich","l":"\n","a":[["id","_dulwich"]]},{"n":"p","x":"\nThere is also a pure-Python Git implementation - Dulwich.\nThe project is hosted under ","l":"\n","c":[{"n":"a","x":"https://www.dulwich.io/","l":"\nIt aims to provide an interface to git repositories (both local and remote) that doesn’t call out to git directly but instead uses pure Python.\nIt has an optional C extensions though, that significantly improve the performance.","a":[["href","https://www.dulwich.io/"],["class","link"]]}]},{"n":"p","x":"Dulwich follows git design and separate two basic levels of API: plumbing and porcelain.","l":"\n"},{"n":"p","x":"Here is an example of using the lower level API to access the commit message of the last commit:","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-python"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"from","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"dulwich.repo","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"import","l":" Repo\nr = Repo(","a":[["style","font-weight: bold"]]},{"n":"span","x":"'.'","l":")\nr.head()\n","a":[["style","font-style: italic"]]},{"n":"span","x":"# '57fbe010446356833a6ad1600059d80b1e731e15'","l":"\n\nc = r[r.head()]\nc\n","a":[["style","font-style: italic"]]},{"n":"span","x":"# <Commit 015fc1267258458901a94d228e39f0a378370466>","l":"\n\nc.message\n","a":[["style","font-style: italic"]]},{"n":"span","x":"# 'Add note about encoding.\\n'","a":[["style","font-style: italic"]]}]}]}]},{"n":"p","x":"To print a commit log using high-level porcelain API, one can use:","l":"\n"},{"n":"figure","x":"\n","l":"\n","a":[["class","listing"]],"c":[{"n":"pre","l":"\n","a":[["class","source language-python"]],"c":[{"n":"code","c":[{"n":"span"},{"n":"span","x":"from","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"dulwich","l":" ","a":[["style","font-weight: bold"]]},{"n":"span","x":"import","l":" porcelain\nporcelain.log(","a":[["style","font-weight: bold"]]},{"n":"span","x":"'.'","l":", max_entries=1)\n\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#commit: 57fbe010446356833a6ad1600059d80b1e731e15","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#Author: Jelmer Vernooĳ <jelmer@jelmer.uk>","l":"\n","a":[["style","font-style: italic"]]},{"n":"span","x":"#Date:   Sat Apr 29 2017 23:57:34 +0000","a":[["style","font-style: italic"]]}]}]}]},{"n":"section","x":"\n","l":"\n","a":[["class","sect2"],["title","Further Reading"]],"c":[{"n":"h3","x":"Further Reading","l":"\n","a":[["id","_further_reading_2"]]},{"n":"p","x":"The API documentation, tutorial, and many examples of how to do specific tasks with Dulwich are available on the official website ","l":"\n","c":[{"n":"a","x":"https://www.dulwich.io","l":".","a":[["href","https://www.dulwich.io"],["class","link"]]}]}]}]}]}]}]},"ns_map":["http://www.w3.org/1999/xhtml","http://www.w3.org/XML/1998/namespace","http://www.idpf.org/2007/ops"]}